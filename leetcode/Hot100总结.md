# LeetCode Hot 100 总结

*按难度顺序总结*

## 简单题

### 1. 两数之和
使用Map存储已经出现过的数，这样就可以在O(n)的复杂度下实现查找

### 20. 有效的括号
使用栈

### 21. 合并两个有序链表
双指针，归并排序的合并过程

### 53. 最大子序和
* DP  
dp[i]为到第i个位置的最大子序和的值
```java
dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);
```
* **分治**  
*待完成*

### 70. 爬楼梯
* DP
```java
dp[i] = dp[i-1] + dp[i-2];
```
* 矩阵快速幂
本体实际为求解斐波那契数列，可以使用矩阵快速幂  
$$ 
\begin{bmatrix}1 & 1\\ 1 & 0\end{bmatrix}\begin{bmatrix}f(n) \\ f(n-1)\end{bmatrix} = \begin{bmatrix}f(n+1) \\ f(n)\end{bmatrix}
$$
因此
$$ 
\begin{bmatrix}f(n+1) \\ f(n)\end{bmatrix} = \begin{bmatrix}1 & 1\\ 1 & 0\end{bmatrix}^{n}\begin{bmatrix}f(1) \\ f(0)\end{bmatrix}
$$
矩阵快速幂思路 [LC70题解](https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/)

### 101. 对称二叉树
递归

### 104. 二叉树的最大深度
递归

### 121. 买卖股票的最佳时机
遍历数组，维护当前所有遍历过的元素中的最小值，并更新ans

### 136. 只出现一次的数字
位运算，使用异或解决

### 141. 环形链表
快慢指针，如果有环，必定能在某个时刻相遇

### 155. 最小栈
维护两个栈，一个是正常存储数，另一个存储当前的最小值

### 160. 相交链表
快慢指针，先求两个链表长度差值，再让长的先走，最后就能在相交点相遇

### 169. 多数元素
用一个变量记录当前可能的答案，另一个变量记录当前值出现的次数  
即Boyer-Moore 投票算法，相关证明：[LC169题解](https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/)

### 198. 打家劫舍
DP,两个变量，分别记录在当前位置偷窃或不偷窃的最大受益值  
偷窃 = 前一项不偷窃 + 本项值
不偷窃 = MAX(前一项偷窃，前一项不偷窃)

### 206. 反转链表
递归

### 226. 翻转二叉树
递归

### 234. 回文链表
快慢指针找到分割点，然后翻转链表判断，类似206

### 283. 移动零 $\star$
双指针，左指针指向需要处理的0，右指针遍历每个元素，发现非0元素就交换

### 448. 找到所有数组中消失的数字 $\star$
遍历每个数，对于a[i]，将|a[i]|-1作为下标对应的元素变为负值，最后再遍历一次，a[i]为正数说明i+1没有出现过。

### 461. 汉明距离
先异或，然后利用 x ^ (x - 1) 计算1的个数

### 543. 二叉树的直径
递归，二叉树的最大直径应该等于MAX（左右子树的最大直径， 以自身为中间节点的最大直径（即左右字数深度之和））

### 617. 合并二叉树
递归，注意空值处理
```java
 public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        TreeNode merged = new TreeNode(t1.val + t2.val);
        merged.left = mergeTrees(t1.left, t2.left);
        merged.right = mergeTrees(t1.right, t2.right);
        return merged;
    }
```



