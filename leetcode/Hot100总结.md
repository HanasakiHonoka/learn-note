# LeetCode Hot 100 总结

*按难度顺序总结*

## 简单题

### 1. 两数之和
使用Map存储已经出现过的数，这样就可以在O(n)的复杂度下实现查找

### 20. 有效的括号
使用栈

### 21. 合并两个有序链表
双指针，归并排序的合并过程

### 53. 最大子序和
* DP  
dp[i]为到第i个位置的最大子序和的值
```java
dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);
```
* **分治**  
*待完成*

### 70. 爬楼梯
* DP
```java
dp[i] = dp[i-1] + dp[i-2];
```
* 矩阵快速幂
本体实际为求解斐波那契数列，可以使用矩阵快速幂  
$$ 
\begin{bmatrix}1 & 1\\ 1 & 0\end{bmatrix}\begin{bmatrix}f(n) \\ f(n-1)\end{bmatrix} = \begin{bmatrix}f(n+1) \\ f(n)\end{bmatrix}
$$
因此
$$ 
\begin{bmatrix}f(n+1) \\ f(n)\end{bmatrix} = \begin{bmatrix}1 & 1\\ 1 & 0\end{bmatrix}^{n}\begin{bmatrix}f(1) \\ f(0)\end{bmatrix}
$$
矩阵快速幂思路 [LC70题解](https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/)

### 101. 对称二叉树
递归

### 104. 二叉树的最大深度
递归

### 121. 买卖股票的最佳时机
遍历数组，维护当前所有遍历过的元素中的最小值，并更新ans

### 136. 只出现一次的数字
位运算，使用异或解决

### 141. 环形链表
快慢指针，如果有环，必定能在某个时刻相遇

### 155. 最小栈
维护两个栈，一个是正常存储数，另一个存储当前的最小值

### 160. 相交链表
快慢指针，先求两个链表长度差值，再让长的先走，最后就能在相交点相遇

### 169. 多数元素
用一个变量记录当前可能的答案，另一个变量记录当前值出现的次数  
即Boyer-Moore 投票算法，相关证明：[LC169题解](https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/)

### 198. 打家劫舍
DP,两个变量，分别记录在当前位置偷窃或不偷窃的最大受益值  
偷窃 = 前一项不偷窃 + 本项值
不偷窃 = MAX(前一项偷窃，前一项不偷窃)

### 206. 反转链表
递归

### 226. 翻转二叉树
递归

### 234. 回文链表
快慢指针找到分割点，然后翻转链表判断，类似206

### 283. 移动零 $\star$
双指针，左指针指向需要处理的0，右指针遍历每个元素，发现非0元素就交换

### 448. 找到所有数组中消失的数字 $\star$
遍历每个数，对于a[i]，将|a[i]|-1作为下标对应的元素变为负值，最后再遍历一次，a[i]为正数说明i+1没有出现过。

### 461. 汉明距离
先异或，然后利用 x ^ (x - 1) 计算1的个数

### 543. 二叉树的直径
递归，二叉树的最大直径应该等于MAX（左右子树的最大直径， 以自身为中间节点的最大直径（即左右字数深度之和））

### 617. 合并二叉树
递归，注意空值处理
```java
 public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        TreeNode merged = new TreeNode(t1.val + t2.val);
        merged.left = mergeTrees(t1.left, t2.left);
        merged.right = mergeTrees(t1.right, t2.right);
        return merged;
    }
```

## 中等题

### 2. 两数相加
链表模拟加法，注意进位

### 3. 无重复字符的最长子串
双指针，记录

### 5. 最长回文子串
dp，dp[i][j]为第i到第j个字符是否为回文字符串，dp[i][i] = 1, dp[i][j] = dp[i][j] && s[i] == s[j]
注意预处理dp[i][i+1]的情况，并且根据长度来进行迭代
```java
for (int k = 2; k < len; k++) {
    for (int i = 0; i + k < len; i++) {
        dp[i][i + k] = dp[i+1][i+k-1] && s.charAt(i) == s.charAt(i+k);
        if (dp[i][i+k] && k + 1 > maxs) {
            l = i;
            r = i + k;
            maxs = k + 1;
        }
    }
}
```

### 11. 盛最多水的容器
双指针，从首尾开始向中间收缩，每次收缩短的那一边

### 15. 三数之和
先排序，在选定前两个数后，由于数组是排序的，为了三数之和为0，第三个数可以从最后往前遍历
同时因为不能重复，因此遍历前两个数需要选择每个数字最后出现的那一个

### 17. 电话号码的字母组合
回溯

### 19. 删除链表的倒数第N个节点
一次遍历解决，使用双指针，第一个指针先走N步

### 22. 括号生成
回溯，当左右括号都消耗完时结束，注意在左括号剩余数量比右括号少时，既可以加入左括号，也可以加入右括号，但是左括号数量和右括号一样时，只能加入左括号

### 31. 下一个排列
字典序算法，从最后开始找到第一个比其右边元素小的元素，再从后往前找到第一个大于它的元素，交换它们，并对它们中间的所有字符排序。

### 33. 搜索旋转排序数组
二分查找

### 34. 在排序数组中查找元素的第一个和最后一个位置
二分查找

### 39. 组合总和
回溯

### 46. 全排列
带标记的回溯

### 48. 旋转图像
递归解决

### 55. 跳跃游戏
使用栈

### 56. 合并区间
贪心，首先按照左边界排序，依次遍历加入结果集，每次取出结果集的最后一个元素尝试合并

### 62. 不同路径
dp

### 64. 最小路径和
dp

### 75. 颜色分类 $\star$
双指针， p0来交换0，p2来交换2，用一个i来遍历所有元素，注意和p2交换时，交换完需要检查是否需要再次交换

### 78. 子集
按子集大小分别回溯

### 79. 单词搜索
dfs

### 94. 二叉树的中序遍历
迭代法

### 96. 不同的二叉搜索树
卡塔兰数

### 98. 验证二叉搜索树
递归

### 102. 二叉树的层序遍历
bfs

### 105. 从前序与中序遍历序列构造二叉树



### 114. 二叉树展开为链表 $\star$


### 139. 单词拆分
dp，dp[i]为以i为结尾的字符串是否能被拆分，对于每个位置i，使用一个j遍历0-i之间的位置，如果dp[j]为true且j-i之间的字串在单词表内的话，dp[i]则为true

### 142. 环形链表 II  
快慢指针，当快指针和慢指针在环中相遇时，第三个指针从头开始移动，最终和慢指针在入环点相遇

### 146. LRU 缓存机制
双向链表

### 148. 排序链表
归并排序

### 152. 乘积最大子数组
dp，同时记录到i的最大乘积和最小乘积

### 200. 岛屿数量
bfs，一种巧妙的标记方法为，在每次遍历完某个为1的点之后将其置为0

### 207. 课程表
AOV网，统计出入度即可

### 208. 实现 Trie (前缀树)
前缀树

### 215. 数组中的第K个最大元素
大小为K的最小堆

### 221. 最大正方形
dp,dp[i][j]为以(i, j)为右下角的最大正方形的大小

### 236. 二叉树的最近公共祖先 $\star$

### 238. 除自身以外数组的乘积 $\star$
通过构建两个数组L,R，记录当前坐标左边所有数的乘积和右边所有数的乘积，则ans[i] = L[i] * R[i]
在O(1)的限制下，可以将ans当作L，同时从后往前用一个变量代替R[i]来更新ans[i]

### 240. 搜索二维矩阵 II
从右上开始寻找，如果小于目标值，则答案应该在下方，如果大于，则在左方

### 279. 完全平方数
dp，dp[i]为用完全平方数构成i的最小个数，则dp[i] = Min(dp[i], dp[i - j*j])



