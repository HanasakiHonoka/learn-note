### **DNS解析过程**

DNS 在解析域名的时候有两种方式：**递归查询和迭代查询**。

 **递归查询**：

主机向本地域名服务器的查询一般都是采用**递归查询 **。

如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果是所要查询的IP地址，或者是返回一个失败的响应，表示无法查询到所需的IP地址。

**迭代查询**：

本地域名服务器向根域名服务器的查询通常是采用**迭代查询**。

当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么返回给本地域名服务器所要查询的IP地址，要么返回给本地域名服务器下一步应当查询的域名服务器的IP地址。

**查询步骤**：

① 主机先在浏览器缓存，系统缓存，hosts静态文件、路由器缓存中查找某主机的ip地址，如果没有再向其本地域名服务器进行**递归查询**，如果缓存中没有，继续下一步。

② 本地域名服务器采用**迭代查询**，先向一个**根域名服务器**查询。

③ 根域名服务器告诉本地域名服务器，下一次查询的**顶级域名服务器**ip地址 。

④ 本地域名服务器向顶级域名服务器 。

⑤ 顶级域名服务器告诉本地DNS服务器下一次应查询的**权限域名服务器**的ip地址。

⑥ 本地域名服务器向权限域名服务器的ip地址进行查询。

⑦ 权限域名服务器告诉本地域名服务器，所查询的主机的IP地址。

⑧ 本地域名服务器最后把查询结果告诉主机。

### **什么是DNS劫持**

#### DNS劫持 vs HTTP劫持

DNS劫持现象：你输入一个google.com网址，出来的是百度的页面

HTTP劫持现象：访问着github的页面，右下角出现了一个格格不入的广告弹窗

**好比：**DNS劫持是你想去机场的时候，把你给丢到火车站。 HTTP劫持是你去机场途中，有人给你塞小广告



在dns解析过程中，有哪一环节出现问题的话，都可能会导致DNS解析错误，导致客户端（浏览器）得到一个假的ip地址，从而引导用户访问到这个冒名顶替，恶意的网站。

#### **DNS劫持带来的危害：**

1. 钓鱼诈骗

2. 网上购物支付安全

3. 泄露个人隐私

4. 轻则影响网速，重则不能上网

#### DNS劫持的方法

![](https://www.hualigs.cn/image/6098c9f102c7a.jpg)s

**1.本机DNS劫持**

攻击者通过某些手段使用户的计算机感染上木马病毒，或者恶意软件之后，恶意修改本地DNS配置，比如修改本地hosts文件，缓存等

**2. 路由DNS劫持**

很多用户默认路由器的默认密码，攻击者可以侵入到路由管理员账号中，修改路由器的默认配置

**3.攻击DNS服务器**

直接攻击DNS服务器，例如对DNS服务器进行DDOS攻击，可以是DNS服务器宕机，出现异常请求，还可以利用某些手段感染dns服务器的缓存，使给用户返回来的是恶意的ip地址

#### DNS的防范

> 就这上面的劫持方法，说几种方法手段

**1. 加强本地计算机病毒检查，开启防火墙等，防止恶意软件，木马病毒感染计算机**

**2. 改变路由器默认密码，防止攻击者修改路由器的DNS配置指向恶意的DNS服务器**

**3. 企业的话可以准备两个以上的域名，一旦一个域名挂掉，还可以使用另一个**

**4. 用HTTP DNS 代替 Local DNS**



## HTTP状态码

![状态码](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/状态码.png)

* 100 Continue：

  这是对HTTP LBYL（look-before-you-leap）请求的一个可能的响应。该响应代码表明：客户端应重新发送初始请求，并在请求中附上第一次请求时未提供的（可能很大或者包含敏感信息的）表示。客户端这次发送的请求不会被拒绝。对LBYL请求的另一个可能的响应是417("Expectation Failed")。

  请求报头：要做一个LBYL请求，客户端必须把Expect请求报头设为字符串"100-continue"。除此以外，客户端还需要设置其他一些报头，服务器将根据这些报头决定是响应100还是417。

* 101Switching Protocols：

  当客户端通过在请求里使用Upgrade报头，以通知服务器它想改用除HTTP协议之外的其他协议时，客户端将获得此响应代码。101响应代码表示“行，我现在改用另一个协议了”。通常HTTP客户端会在收到服务器发来的101响应后关闭与服务器的TCP连接。101响应代码意味着，该客户端不再是一个HTTP客户端，而将成为另一种客户端。

* 200 OK：客户端请求成功。

* 201 Created: 

  当服务器依照客户端的请求创建了一个新资源时，发送此响应代码。

  响应报头：Location报头应包含指向新创建资源的规范URI。
  实体主体：应该给出新创建资源的描述与链接。若已经在Location报头里给出了新资源的URI，那么可以用新资源的一个表示作为实体主体。

* 202 Accepted：

  客户端的请求无法或将不被实时处理。请求稍后会被处理。请求看上去是合法的，但在实际处理它时有出现问题的可能。
  若一个请求触发了一个异步操作，或者一个需要现实世界参与的动作，或者一个需要很长时间才能完成且没必要让Web客户端一直等待的动作时，这个相应代码是一个合适的选择。

  响应报头：应该把未处理完的请求暴露为一个资源，以便客户端稍后查询其状态。Location报头可以包含指向该资源的URI。
  实体主体：若无法让客户端稍后查询请求的状态，那么至少应该提供一个关于何时能处理该请求的估计。

* 204 No Content：

  若服务器拒绝对PUT、POST或者DELETE请求返回任何状态信息或表示，那么通常采用此响应代码。服务器也可以对GET请求返回此响应代码，这表明“客户端请求的资源存在，但其表示是空的”。注意与304("Not Modified")的区别。204常常用在Ajax应用里。服务器通过这个响应代码告诉客户端：客户端的输入已被接受，但客户端不应该改变任何UI元素。

* 206 Partial Content：

  它跟200类似，但它用于对部分GET请求（即使用Range请求报头的GET请求）的响应。部分GET请求常用于大型二进制文件的**断点续传**。

  请求报头：客户端为Range请求报头设置一个值。
  响应报头：需要提供**Date报头、ETag报头与Content-Location报头的值**应该跟正常GET请求相同。

  若实体主体是单个字节范围（byte range），那么HTTP响应里必须包含一个Content-Range报头，以说明本响应返回的是表示的哪个部分，若实体主体是一个多部分实体（multipart entity）（即该实体主体由多个字节范围构成），那么每一个部分都要有自己的Content-Range报头。
  实体主体：不是整个表示，而是一个或者多个字节范围。

* 301 Moved Permanently：

  服务器知道客户端试图访问的是哪个资源，但它不喜欢客户端用当前URI来请求该资源。它希望客户端记住另一个URI，并在今后的请求中使用那个新的URI。你可以通过这个响应代码来防止由于URI变更而导致老URI失效。

* 302  Found：

  这个响应代码市造成大多数重定向方面的混乱的最根本原因。它应该是像307那样被处理。实际上，在HTTP 1.0中，响应代码302的名称是”Moved Temporarily”，不幸的是，在实际生活中，绝大多数客户端拿它像303一样处理。
  为了消除这一混淆，在HTTP 1.1中，该响应代码被重命名为"Found"，并新加了一个响应代码307。这个响应代码目前仍在广泛使用，但它的含义是混淆的，所以我建议你的服务发送307或者303，而不要发送302.除非你知道正在与一个不能理解303或307的**HTTP 1.0**客户端交互。

* 303 See Other：

  请求已经被处理，但服务器不是直接返回一个响应文档，而是返回一个响应文档的URI。该响应文档可能是一个静态的状态信息，也可能是一个更有趣的资源。对于后一种情况，303是一种令服务器可以“发送一个资源的表示，而不强迫客户端下载其所有数据”的方式。客户端可以向Location报头里的URI发送GET请求，但它不是必须这么做。
  303响应代码是一种规范化资源URI的好办法。一个资源可以有多个URIs，但每个资源的规范URI只有一个，该资源的所有其他URIs都通过303指向该资源的规范URI，例如：303可以把一个对http://www.example.com/software/current.tar.gz的请求重定向到http://www.example.com/software/1.0.2.tar.gz

* 304 Not Modified

  这个响应代码跟204("No Content")类似：响应实体主体都必须为空。但204用于没有主体数据的情况，而304用于有主体数据，但客户端已拥有该数据，没必要重复发送的情况。这个响应代码可用于条件HTTP请求（conditional HTTP request).如果客户端在发送GET请求时附上了一个值为Sunday的If-Modified-Since报头，而客户端所请求的表示在服务器端自星期日（Sunday）以来一直没有改变过，那么服务器可以返回一个304响应。服务器也可以返回一个200响应，但由于客户端已拥有该表示，因此重复发送该表示只会白白浪费宽带。

  响应报头：需要提供Date报头。Etag与Content-Location报头的值，应该跟返回200响应时的一样。若Expires, Cache-Control及Vary报头的值自上次发送以来已经改变，那么就要提供这些报头

* 307 Temporary Redirect

  请求还没有被处理，因为所请求的资源不在本地：它在另一个URI处。客户端应该向那个URI重新发送请求。就GET请求来说，它只是请求得到一个表示，该响应代码跟303没有区别。当服务器希望把客户端重新定向到一个镜像站点时，可以用307来响应GET请求。

  但对于POST，PUT及DELETE请求，它们希望服务器执行一些操作，307和303有显著区别。对POST，PUT或者DELETE请求响应**303表明**：操作**已经成功执行**，但响应实体将不随本响应一起返回，若客户端想要获取响应实体主体，它需要向另一个URI发送GET请求。而307表明：**服务器尚未执行操作**，客户端需要向Location报头里的那个URI重新提交整个请求。

* 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。

* 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。

  客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书。客户端提供了错误的证书，或者根本没有提供证书。这里的证书（credential）可以是一个用户名/密码，也可以市一个API key，或者一个认证令牌。**客户端常常通过向一个URI发送请求，并查看收到401响应，以获知应该发送哪种证书，以及证书的格式**。如果服务器不想让未授权的用户获知某个资源的存在，那么它可以谎报一个404而不是401。这样做的缺点是：客户端需要事先知道服务器接受哪种认证--这将导致**HTTP摘要认证**无法工作。

* 403 Forbidden：服务器收到请求，但是拒绝提供服务。

* 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。

  这也许是最广为人知的HTTP响应代码了。404表明服务器无法把客户端请求的URI转换为一个资源。相比之下，410更有用一些。web服务可以通过404响应告诉客户端所请求的URI是空的，然后客户端就可以通过向该URI发送PUT请求来创建一个新资源了。但是404也有可能是用来掩饰403或者401.

* 405 Method Not Allowd

  客户端试图使用一个本资源不支持的HTTP方法。例如：一个资源只支持GET方法，但是客户端使用PUT方法访问。

  响应报头：Allow报头列出本资源支持哪些HTTP方法，例如：Allow：GET，POST。

* 409 Conflict

  你请求的操作会导致服务器的资源处于一种不可能或不一致的状态。例如你试图修改某个用户的用户名，而修改后的用户名与其他存在的用户名冲突了。

* 410 Gone

  这个响应代码跟404类似，但它提供的有用信息更多一些。这个响应代码用于服务器知道被请求的URI过去曾指向一个资源，但该资源现在不存在了的情况。服务器不知道该资源的新URI.

* 412 Precondition Failed

  客户端在请求报头里指定一些前提条件，并要求服务器只有在满足一定条件的情况下才能处理本请求。若服务器不满足这些条件，就返回此响应代码。If-Unmodified-Since是一个常见的前提条件。客户端可以通过PUT请求来修改一个资源，但它要求，仅在自客户端最后一次获取该资源后该资源未被别人修改过才能执行修改操作。若没有这一前提条件，客户端可能会无意识地覆盖别人做的修改，或者导致409的产生。

  请求报头：若客户但设置了If-Match，If-None-Match或If-Unmodified-Since报头，那就有可能得到这个响应代码。If-None-Match稍微特别一些。若客户端在发送GET或HEAD请求时指定了If-None-Match，并且服务器不满足该前提条件的话，那么响应代码不是412而是304，这是实现条件HTTP GET的基础。若客户端在发送PUT，POST或DELETE请求时指定了If-None-Match,并且服务器不满足该前提条件的话，那么响应代码是412.另外，若客户端指定了If-Match或If-Unmodified-Since(无论采用什么HTTP方法)，而服务器不满足该前提条件的话，响应代码也是412。

* 500 Internal Server Error：服务器发生不可预期的错误。

* 502 Bad Gateway

  只有HTTP代理会发送这个响应代码。它表明代理方面出现问题，或者代理与上行服务器之间出现问题，而不是上行服务器本身有问题。若代理根本无法访问上行服务器，响应代码将是504。

* 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。

  

  此响应代码表明HTTP服务器正常，只是下层web服务服务不能正常工作。最可能的原因是资源不足：服务器突然收到太多请求，以至于无法全部处理。由于此问题多半由客户端反复发送请求造成，因此HTTP服务器可以选择拒绝接受客户端请求而不是接受它，并发送503响应代码。

  服务器可以通过Retry-After报头告知客户端何时可以重试。

* 504 Gateway Timeout

  跟502类似，只有HTTP代理会发送此响应代码。此响应代码表明代理无法连接上行服务器。



### Vary响应头

Vary存在于响应头中，它的内容来自于请求头中相关字段，Vary头的内容如果是多条则用“,”分割。缓存服务器会将某接口的首次请求结果缓存下来（包括响应头中的Vary），后面在发生相同请求的时候缓存服务器会拿着缓存的Vary来进行判断。比如Vary: Accept-Encoding,User-Agent，那么Accept-Encoding与User-Agent两个请求头的内容，就会作为判断是否返回缓存数据的依据，当缓存服务器中相同请求的缓存数据的编码格式、代理服务与当前请求的编码格式、代理服务一致，那就返回缓存数据，否则就会从服务器重新获取新的数据。当缓存服务器中已经缓存了该条请求，那么某次服务器端的响应头中如果Vary的值改变，则Vary会更新到该请求的缓存中去，下次请求会对比新的Vary内容。

官方解释Vary头：告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。

##### 总结

1. Vary是作为响应头由服务器端返回数据时添加的头部信息；

2. Vary头的内容来自于当前请求的Request头部Key，比如Accept-Encoding、User-Agent等；

3. 缓存服务器进行某接口的网络请求结果数据缓存时，会将Vary一起缓存；

4. HTTP请求，缓存中Vary的内容会作为当前缓存数据是否可以作为请求结果返回给客户端的判断依据；

5. HTTP请求，响应数据中的Vary用来判断当前缓存中同请求的数据的Vary是否失效，如果缓存中的Vary与服务器刚拿到的Vary不一致，则可以进行更新。

6. 当Vary的值为“*”，意味着请求头中的所有信息都不可作为是否从缓存服务器拿数据的判断依据。



### 如何实现断点续传

断点续传说白了就是将一个文件按照一定的规则人为的分割成多个小文件，然后客户端每次只上传一个小文件（当然我们也可以利用多线程技术每次上传多个小文件），服务器接收到上传过来的小文件后根据一定的规则来组合这些小文件。如果在上传过程中出现网络中断等意外情况，下次再次上传时可以从已经上传的部分继续上传，而不是重新上传。

从 HTTP1.1 协议开始就已经支出获取文件的部分内容，断点续传技术就是利用 HTTP1.1 协议的这个特点在 Header 里添加两个参数来实现的。这两个参数分别是客户端请求时发送的 Range 和服务器返回信息时返回的 Content-Range 。

格式如下：

Range:(unit=first byte pos)-[last byte pos]

Content-Range:bytes(unit first byte pos)-[last byte pos]/[entity length]

常见的格式内容如下：

Range:bytes=1025-2048 

Content-Range:bytes 2048-4096/10240

**校验**

当服务器端的文件发生改变时，客户端再次向服务端发送断点续传请求时，数据肯定就会发生错误。当使用校验的时候我们不需要手动实现验证，只需要利用 if-Range 结合 Last-Modified 或者 Etage 来判断是否发生改变，如果没有发生改变服务器将向客户端发送剩余的部分，否则发送全部。

注意：If-Range 必须与 Range 配套使用。缺少其中任意一个另一个都会被忽略。



### 如何实现秒传

**原理**

秒传利文件的MD5，首先将文件的MD5发送个服务器，服务器传输过来的MD5判断服务器上是否存在相同类型的文件，如果存在就将文件复制一份，而不是本地上传。这样就是先的秒传功能。

**MD5**

秒传涉及到了MD5，那么什么MD5呢？MD5的英文全称是 Message-Digest Algorith 5 ,是计算机广泛使用的算法之一。 MD5 会为文件产生唯一的“指纹”，任何改动都会改变文件指纹。它以 512位分组来处理信息，每个分组又被分为16个32位分组，经过处理后输出4个32位分组，最后将输出的4个32位分组进行级联生成128位散列值。

MD5的具有压缩性、易计算、抗修改、弱抗碰撞和强抗碰撞。下面我们一一来讲解：

**压缩性**：任意长度数据，生成的MD5值长度是固定的；

**易计算**：可以很方便的从原始数据计算出MD5；

**抗修改**：对原始数据的任何修改，都会改变MD5；

**弱抗碰撞和强抗碰撞**：很难找到具有相同MD5的数据。

破解谣言：有人说网盘能秒传证明数据在网盘服务器是不加密的，有数据库查看权限的人都可以看，所以私密文件最好在本地磁盘加密后再上传到网盘中。这句话是错误的，正规的网盘服务器只是验证了文件的MD5码，文件还是加密存放的。



## Nginx

### 1. 什么是Nginx？

Nginx ，是一个 Web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。目前使用的最多的 Web 服务器或者代理服务器，像淘宝、新浪、网易、迅雷等都在使用。
Nginx 的主要功能如下：

1. 作为 http server (代替 Apache ，对 PHP 需要 FastCGI 处理器支持)
2. FastCGI：Nginx 本身不支持 PHP 等语言，但是它可以通过 FastCGI 来将请求扔给某些语言或框架处理。
3. 反向代理服务器
4. 实现负载均衡
5. 虚拟主机

### 2.fastcgi 与 cgi 的区别？

1）cgi
web 服务器会根据请求的内容，然后会 fork 一个新进程来运行外部 c 程序（或 perl 脚本…）， 这个进程会把处理完的数据返回给 web 服务器，最后 web 服务器把内容发送给用户，刚才 fork 的进程也随之退出。
如果下次用户还请求改动态脚本，那么 web 服务器又再次 fork 一个新进程，周而复始的进行。

2）fastcgi
web 服务器收到一个请求时，他不会重新 fork 一个进程（因为这个进程在 web 服务器启动时就开启了，而且不会退出），web 服务器直接把内容传递给这个进程（进程间通信，但 fastcgi 使用了别的方式，tcp 方式通信），这个进程收到请求后进行处理，把结果返回给 web 服务器，最后自己接着等待下一个请求的到来，而不是退出。

### 3. Nginx 常用命令

```
启动  nginx 。
停止  nginx -s stop 或 nginx -s quit 。
重载配置  ./sbin/nginx -s reload(平滑重启) 或 service nginx reload 。
重载指定配置文件  .nginx -c /usr/local/nginx/conf/nginx.conf 。
查看nginx版本 nginx -v 。
检查配置文件是否正确  nginx -t 。
显示帮助信息  nginx -h 。
```

### 4. Nginx 有哪些优点？

- 跨平台、配置简单。

- 非阻塞、高并发连接

  处理 2-3 万并发连接数，官方监测能支持 5 万并发。

- 内存消耗小

  开启 10 个 Nginx 才占 150M 内存。

- 成本低廉，且开源。

- 稳定性高，宕机的概率非常小。

### 5. **请列举 Nginx 和 Apache 之间的不同点？**

- 轻量级，同样起 web 服务，Nginx 比 Apache 占用更少的内存及资源。
- 抗并发，Nginx 处理请求是异步非阻塞的，而 Apache 则是阻塞型的，在高并发下 Nginx 能保持低资源低消耗高性能。
- 最核心的区别在于 Apache 是同步多进程模型，一个连接对应一个进程；Nginx 是异步的，多个连接（万级别）可以对应一个进程。
- Nginx 高度模块化的设计，编写模块相对简单。

### 6. **Nginx 是如何实现高并发的？**

如果一个 server 采用一个进程(或者线程)负责一个request的方式，那么进程数就是并发数。那么显而易见的，就是会有很多进程在等待中。等待最多的应该是网络传输。

而 Nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的时候，这些进程就空闲出来待命了。因此表现为少数几个进程就解决了大量的并发问题。

Nginx是如何利用的呢，简单来说：同样的 4 个进程，如果采用一个进程负责一个 request 的方式，那么，同时进来 4 个 request 之后，每个进程就负责其中一个，直至会话关闭。期间，如果有第 5 个request进来了。就无法及时反应了，因为 4 个进程都没干完活呢，因此，一般有个调度进程，每当新进来了一个 request ，就新开个进程来处理。

Nginx 不这样，每进来一个 request ，会有一个 worker 进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游（后端）服务器转发 request ，并等待请求返回。那么，这个处理的 worker 不会这么傻等着，他会在发送完请求后，注册一个事件：“如果 upstream 返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有 request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker 才会来接手，这个 request 才会接着往下走。

这就是为什么说，Nginx 基于事件模型。

由于 web server 的工作性质决定了每个 request 的大部份生命都是在网络传输中，实际上花费在 server 机器上的时间片不多。这是几个进程就解决高并发的秘密所在。即：

**webserver 刚好属于网络 IO 密集型应用，不算是计算密集型。**

而正如叔度所说的

**异步，非阻塞，使用 epoll ，和大量细节处的优化。**

也正是 Nginx 之所以然的技术基石。

### 7. **为什么 Nginx 不使用多线程？**

Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。

Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。

### 8. **Nginx 有哪些负载均衡策略？**

负载均衡，即代理服务器将接收的请求均衡的分发到各服务器中。

Nginx 默认提供了 3 种负载均衡策略：

**1、轮询（默认）round_robin**

每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。

**2、IP 哈希 ip_hash**

每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题。

当然，实际场景下，一般不考虑使用 ip_hash 解决 session 共享。

**3、最少连接 least_conn**

下一个请求将被分派到活动连接数量最少的服务器