## 从输入URL到页面展现的整个过程

**简单路径线**：

1. 键盘或触屏输入URL并回车确认
2. URL解析/DNS解析查找域名IP地址
3. 网络连接发起HTTP请求
4. HTTP报文传输过程
5. 服务器接收数据
6. 服务器响应请求
7. 服务器返回数据
8. 客户端接收数据
9. 浏览器加载/渲染页面
10. 打印绘制输出



1. ### **键盘或触屏输入URL并回车确认**

当我们在地址栏中输入时，UI 线程会先判断我们输入的内容是要搜索的内容还是要访问一个站点，因为地址栏同时也是一个搜索框。在这过程中，浏览器会做一些预处理，智能匹配所有可能的URL（从历史记录，书签等地方，来预估所输入字符对应的网站，然后给出智能提示）因此就会在输入回车前就开始建立 TCP 链接了。 Chrome甚至会在按回车键前直接从缓存中把网页渲染出来。再比如Chrome会在浏览器启动时预先查询10个你有可能访问的域名等等其它策略。 

2. ### **URL 解析/DNS 查询**

浏览器对 URL 进行检查时首先判断协议，如果是 http/https 就按照 Web 来处理，另外还会对 URL 进行安全检查，接下来是对网络地址进行处理，如果地址不是一个IP地址而是域名则通过DNS（域名系统）将该地址解析成IP地址。

3. ### **应用层客户端发送HTTP请求**

从上面的步骤中得到 IP 地址后，浏览器会开始构造一个 HTTP 请求，应用层客户端向服务器端发送的HTTP请求包括：请求报头和请求主体两个部分，其中请求报头（request header）包含了至关重要的信息，包括请求的方法（GET / POST和不常用的PUT / DELETE以及更不常用的HEAD / OPTION / TRACE，一般的浏览器只能发起 GET 或者 POST 请求）、目标url、遵循的协议（HTTP / HTTPS / FTP…），返回的信息是否需要缓存，以及客户端是否发送Cookie等信息。需要注意的是，因为 HTTP 请求是纯文本格式的，所以在 TCP 的数据段中可以直接分析 HTTP 文本的。

4. ### **传输层TCP传输报文**

当应用层的 HTTP 请求准备好后，浏览器会在传输层发起一条到达服务器的 TCP 连接，位于传输层的TCP协议为传输报文提供**可靠的字节流**服务。它为了方便传输，将大块的数据分割成以**报文段**为单位的**数据包**进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。

5. ### **网络层IP协议查询MAC地址**

IP协议的作用是把TCP分割好的各种**数据包**封装到**IP包**里面传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址才可以。IP地址和MAC地址是**一一对应**的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。**ARP协议**可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。

6. ### **数据到达数据链路层**

在找到对方的MAC地址后，已被封装好的**IP包**再被封装到数据链路层的**数据帧**结构中，将数据发送到数据链路层传输，再通过物理层的**比特流**送出去。这时，客户端发送请求的阶段结束。

*这些分层的意义在于分工合作，**数据链路层**通过 **CSMA/CD 协议**保证了**相邻两台主机之间**的数据报文传递，而**网络层**的 IP 数据包通过**不同子网**之间的**路由器的路由算法和路由转发**，保证了互联网上**两台遥远主机之间**的**点对点**的通讯，不过这种传输是**不可靠**，于是**可靠性**就由传输层的 **TCP 协议来保证**，TCP 通过慢开始，乘法减小等手段来进行流量控制和拥塞避免，同时提供了两台遥远主机上进程到进程的通信，最终保证了 HTTP 的请求头能够被远方的服务器上正在监听的 HTTP 服务器进程收到，终于，数据包在跳与跳之间被拆了又封装，在子网与子网之间被转发了又转发，最后进入了服务器的操作系统的缓冲区，服务器的操作系统由此给正在被阻塞住的 accept 函数一个返回，将他唤醒。*

7. ###  **服务器接收数据**

接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在传输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文。

8. ### **服务器响应请求并返回相应文件**

服务接收到客户端发送的HTTP请求后，服务器上的的 http 监听进程会得到这个请求，然后一般情况下会启动一个新的子进程去处理这个请求，同时父进程继续监听。http 服务器首先会查看重写规则，然后如果请求的文件是真实存在，例如一些图片，或 html、css、js 等静态文件，则会直接把这个文件返回，如果是一个动态的请求，则调用动态文件脚本解释器来处理这个请求。

9. ### **浏览器开始处理数据信息并渲染页面**

响应到达浏览器之后，浏览器首先会根据状态码判断。如果是 200 开头表示请求成功，进入渲染流程。如果是 300 开头的就要去相应头里面找 location 域，根据这个 location 的指引，进行跳转，这里跳转需要开启一个跳转计数器，是为了避免两个或者多个页面之间形成的循环的跳转，当跳转次数过多之后，浏览器会报错，同时停止如果是 400 开头或者 500 开头的状态码，浏览器也会给出一个错误页面。

当浏览得到一个正确的 200 响应之后，接下来面临的一个问题就是多国语言的编码解析了，响应头是一个 ascii 的标准字符集的文本，响应的正文本质上就是一个字节流。需要按照响应头里面指定的 encoding 域去解析字符。

接下来就是构建 dom 树。构建出来的 dom 本质上还是一棵抽象的逻辑树，构建 dom 树的过程中，发现`<script>`标签时，会暂停接下来的 HTML 转化工作，然后加载、解析并且运行 Javascript 代码。如果我们的 Javascript 代码并不需要改变 DOM，可以为`<script>`标签添加`async`或`defer`属性，这样浏览器就会异步的加载这些资源并且不会阻塞 HTML 转化过程。

如果遇到 css 代码，也会保存下来，用于稍后的渲染。如果遇到了 img 或 css 和 js等引用外部文件的标签，那么浏览器会根据指定的 url 再次发起一个新的 http 请求，去把这个文件拉取回来，值得一提的是，对于同一个域名下的下载过程来说，浏览器一般允许的并发请求是有限的，通常控制在**两个**左右，所以如果有很多的图片的话，一般出于优化的目的，都会把这些图片使用一台静态文件的服务器来保存起来，负责响应，从而减少主服务器的压力。

dom 树构造好了之后，就是根据 dom 树和 css 样式表来构造 render 树，这是真正的用于渲染到页面上的一个一个的矩形框的树，是浏览器最复杂最核心的功能，对于 render 树上每一个框，需要确定他的 x y 坐标，尺寸，边框，字体，形态，等等诸多方面的东西。

render树构建完成后，主线程遍历render树并创建绘制（paint）记录和Layout tree，绘制记录是一系列由绘制步骤组成的流程，例如先绘制背景，然后是文字，然后是形状。最后通过**合成线程与栅格线程**将页面展示出来。合成线程会将每个图层切割成一个个小图块输入栅格线程进行栅格化处理，随后合成线程接收到栅格线程返回的draw quards信息，生成合成器帧，将其交给GPU进行渲染。

需要说明的是，下载页面，构建 dom 树，构建 render 树这三个步骤，实际上并不是**严格的先后顺序**的，为了加快速度，提高效率，现在一般都并行的往前推进的，现代的浏览器都是一边下载，下载到了一点数据就开始构建 dom 树，也一边开始构建 render 树，构建了一点就显示一点出来，这样用户就不用等待那么久。





## **浏览器缓存机制**

### **缓存过程分析**

浏览器第一次向服务器发起该请求后拿到请求结果，将请求结果和缓存标识存入浏览器缓存中。浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是**强制缓存**和**协商缓存**。

###  **强制缓存**

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种。

1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求。
2. 存在该缓存结果和缓存标识，但该结果失效，强制缓存失效，则使用协商缓存。（失效可能的情况：Cache-Control: no-cache, no-store（不使用协商缓存）, max-age或Expires）。
3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效。

#### **强制缓存的缓存规则**

控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

**Expires**

Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。而Cache-Control的max-age是相对时间。

**Cache-Control**

public：所有内容都将被缓存（客户端和代理服务器都可缓存）

private：所有内容只有客户端可以缓存，Cache-Control的默认取值

no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定

no-store：客户端缓存内容，既不使用强制缓存，也不使用协商缓存。

max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效。

### **协商缓存**

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

1. 协商缓存生效，返回304。客户端从浏览器缓存中获取该请求的缓存结果。
2. 协商缓存失效，返回200和请求结果结果。客户端将请求结果和缓存标识存入浏览器缓存中。

控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

#### Last-Modified / If-Modified-Since

Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器端会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。

#### Etag / If-None-Match

Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。

#### **总结**

强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。

Etag 主要为了解决 Last-Modified 无法解决的一些问题：
1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
3、某些服务器不能精确的得到文件的最后修改时间。

但是也有时候 Last-Modified 可以弥补 ETag 判断的缺陷，比如一些图片等静态文件的修改，如果每次扫描内容生成 ETag 来比较，显然要比直接比较修改时间慢很多。

## **什么是memory cache？什么是disk cache？两者有什么区别？**

1. **Memory Cache**

内存缓存是一种比较特殊的缓存，他不受max-age、no-cache等配置的影响，即使我们不设置缓存，如果当前的内存空间比较充裕的话，一些资源还是会被缓存下来。如果真的不想使用缓存，可以设置**no-store**，这样，即便是内存缓存，也不会生效。内存缓存具有两个特点，分别是快速读取和时效性。

- 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。
- 时效性：一旦该进程关闭，则该进程的内存则会清空。

内存缓存虽然比较高效，但还是受限于计算机内存的大小，所以能让我们使用的内存并不多，这个时候就需要硬盘来存储大量的缓存。

2. **Disk Cache**

硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。相比较内存缓存的优势就是长时效。如果当前内存使用率高的话，请求资源大概率会被缓存到disk cache。

在浏览器中，浏览器会在**js和图片等文件解析执行后**直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而**css文件**则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。



## **重排和重绘**

### 渲染

在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。

### **重排比重绘大**

- 重绘：当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。例如：元素的填充颜色。
- 重排：重排也叫回流，重新生成布局，重新排列元素。当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。

就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。比如改变元素高度，这个元素乃至周边dom都需要重新绘制。

也就是说：**重绘不一定导致重排，但重排一定会导致重绘**。

### 重排优化建议

1. **减小重排范围**

我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。

- 尽可能改变在低层级的DOM节点上，比如你要改变p的样式，class就不要加在div上，通过父元素去影响子元素不好。
- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。

2. **减少重排次数**

* 样式集中改变
* 分离读写操作（当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。）
* 将DOM离线（使用 display:none **或** 复制节点，在副本上工作，然后替换它）
* 使用absolute或fixed脱离文档流（使用绝对定位会使的该元素单独成为渲染树中 `body` 的一个子元素，重排开销比较小，不会对其它节点造成太多影响）
* 优化动画（可以把动画效果应用到 `position`属性为 `absolute` 或 `fixed` 的元素上，这样对其他元素影响较小 **或** 启用 `GPU` 硬件加速）



## **V8垃圾回收策略**

**V8内存结构**

`新生代(new_space)`：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。

`老生代(old_space)`：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为`老生代指针区`和`老生代数据区`，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。

`大对象区(large_object_space)`：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。

`代码区(code_space)`：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。

`map区(map_space)`：存放Cell和Map，每个区域都是存放相同大小的元素，结构简单。

**新生代**

新生代主要用于存放存活时间较短的对象。新生代内存是由两个`semispace(半空间)`构成的，内存最大值在`64`位系统和`32`位系统上分别为`32MB`和`16MB`，在新生代的垃圾回收过程中主要采用了`Scavenge`算法。

在`Scavenge`算法的具体实现中，主要采用了`Cheney`算法，它将新生代内存一分为二，每一个部分的空间称为`semispace`，其中处于激活状态的区域我们称为`From`空间，未激活的区域我们称为`To`空间。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。

我们的程序中声明的对象首先会被分配到`From`空间，当进行垃圾回收时，如果`From`空间中尚有存活对象，则会被复制到`To`空间进行保存，非存活的对象会被自动回收。当复制完成后，`From`空间和`To`空间完成一次角色互换，`To`空间会变为新的`From`空间，原来的`From`空间则变为`To`空间。该算法的缺点也比较明显，浪费了一半的内存用于复制。

**对象晋升**

当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为**晋升**。
 对象晋升的条件主要有以下两个：

- 对象是否经历过一次`Scavenge`算法
- `To`空间的内存占比是否已经超过25%

**老生代**

在老生代中，因为管理着大量的存活对象，如果依旧使用`Scavenge`算法的话，很明显会浪费一半的内存，因此已经不再使用`Scavenge`算法，而是采用新的算法`Mark-Sweep(标记清除)`和`Mark-Compact(标记整理)`来进行管理。

为了避免循环引用导致的内存泄漏问题，截至2012年所有的现代浏览器均放弃了**引用计数**法，转而采用新的`Mark-Sweep(标记清除)`和`Mark-Compact(标记整理)`算法。

**Mark-Sweep(标记清除)**分为`标记`和`清除`两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。`Mark-Sweep`算法主要是通过判断某个对象是否可以被访问到，从而知道该对象是否应该被回收，具体步骤如下：

- 垃圾回收器会在内部构建一个`根列表`，用于从根节点出发去寻找那些可以被访问到的变量。比如在JavaScript中，`window`全局对象可以看成一个根节点。
- 然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。
- 最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。

在经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，所以就会出现内存碎片的问题，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收，而这次垃圾回收其实是没必要的，因为我们确实有很多空闲内存，只不过是不连续的。

**Mark-Compact(标记整理)**算法被提了出来，该算法主要就是用来解决内存的碎片化问题的，回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存.

**补充**

由于JS的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为`全停顿(stop-the-world)`。因此，为了减少垃圾回收带来的停顿时间，V8引擎又引入了`Incremental Marking(增量标记)`的概念，即先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。

得益于增量标记的好处，V8引擎后续继续引入了`延迟清理(lazy sweeping)`和`增量式整理(incremental compaction)`，让清理和整理的过程也变成增量式的。同时为了充分利用多核CPU的性能，也将引入`并行标记`和`并行清理`，进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。



## **如何避免内存泄漏**

1. 尽可能少的创建全局变量

2. 手动清除定时器

3. 少用闭包

4. 清除dom引用

5. 弱引用（在ES6中为新增了两个有效的数据结构`WeakMap`和`WeakSet`，就是为了解决内存泄漏的问题而诞生的。它的键名所引用的对象均是弱引用，弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，这也就意味着我们不需要关心`WeakMap`中键名对其他对象的引用，也不需要手动地进行引用清除。）



## **cookie、session、token**

`https://blog.csdn.net/qq_40925189/article/details/107030620`

cookie和session都是用来跟踪浏览器用户身份的会话方式。

**cookie和session的区别：**

1. 保持状态：cookie保存在浏览器端，session保存在服务器端。

2. 使用方式：

* cookie机制：如果**不在浏览器中设置过期时间**，cookie被保存在**内存**中，生命周期随浏览器的关闭而结束，这种cookie简称**会话cookie**。如果在浏览器中**设置了cookie的过期时间**，cookie被保存在**硬盘**中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它。

* session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。

3. 存储内容：cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)

4. 存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。

5. 安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。

**Token**

token，可以翻译成"令牌"，本质上它是一个全局唯一的字符串，用来唯一识别一个客户端。对数据用算法加密钥做一个签名，  把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。
这个token 服务器端不保存， 当token 发过来的时候，再用同样的算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较， 如果相同， 就知道用户登录过了，并且可以直接取到user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者： 对不起，没有认证。

**Token相比session的优势**

1. 无状态、可扩展
2. 支持移动设备
3. 跨程序调用
4. 安全

**为什么token可以防止CSRF？**

Token被用户端放在Cookie中（不设置HttpOnly），同源页面每次发请求都在请求头或者参数中加入Cookie中读取的Token来完成验证。CSRF只能通过浏览器自己带上Cookie，不能操作Cookie来获取到Token并加到http请求的参数中。

## **sessionStorage 和 localStorage**

**sessionStorage**：将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。

**localStorage**：将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。

**区别**：localStorage生命周期是**永久**，除非用户清除localStorage信息，否则这些信息将永远存在；sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过它存储的数据也就被清空了。

不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。



## **前端优化**

雅虎前端优化的35条军规

`https://www.cnblogs.com/xianyulaodi/p/5755079.html`

1. **尽量减少HTTP请求**

（1）合并文件

（2）雪碧图

（3）将javascript和css从外部引入

（4）图片base64编码

图片太大不宜采用这种方式，因为Base64编码之后会增加图片大小，这样页面整体的下载量会变大；- 内联图片在页面跳转的时候不会被缓存。（大图片可以使用浏览器的本地缓存，在首次访问的时候保存到浏览器缓存中，典型的是HTML5的manifest缓存机制以及LocalStorage等）。

（5）使用缓存

2. **减少DNS查找**
DNS查询有时间开销，通常一个浏览器查找一个给定主机名的IP地址需要20-120ms。缓存DNS：缓存DNS查询可以很好地提高网页性能，一旦缓存了DNS查询，之后对于相同主机名的请求就无需进行再次的DNS查找，至少短时间内不需要。所以在使用页面中URL、图片、js文件、css文件等时，不要使用过多不同的主机名。

3. **避免重定向**
在我们实际开发中避免重定向最简单也最容易被忽视的一个问题就是，设置URL的时候，最后的“/”，有些人有时候会忽略，其实你少了“/”，这时候的URL就被重定向了，所以在给页面链接加URL的时候切记最后的“/”不可丢。

4. **让Ajax可缓存**

5. **减小请求文件大小**

（1）压缩html/css/js/图片文件大小

（2）减少DOM数量，减小访问DOM数量

（3）减小cookie大小

6. **其他优化**

（1）按需加载：lazyload、滚屏加载、Media Query加载

（2）预加载：loading、提前加载下一页

（3）css、js放在正确的位置

（4）适度使用cdn
静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。

7. **预解析DNS**
    如：

  ```
  <link rel="dns-prefetch" href="//img20.360buyimg.com">
  ```

  


## **XSS攻击**

XSS是跨站脚本攻击(Cross Site Scripting)，是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建HTML部分有可能隐藏着安全漏洞。就这样攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。

**实例应用**

1. 劫持流量实现恶意跳转（劫持访问）
2. 盗用cookie实现无密码登录
3. 配合CSRF完成恶意请求
4. 利用虚假输入表单骗取用户个人信息

**防范手段**

1. **过滤**。对诸如`<script>`、`<img>`、`<a>`等标签进行过滤。
2. **编码**。像一些常见的符号，如<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。
3. **限制**。我们不难发现xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。

4. **HttpOnly**。cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击

## **CSRF攻击**

**概念：**

CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：
	攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

 **防御CSRF攻击：**

​    目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。

## **跨域处理**

**同源策略**：

 Ajax可以在不向服务器提交完整的页面的情况下，实现局部更新页面。但是浏览器处于对安全方面的考虑，不允许跨域调用其他页面的对象，这对于我们在注入 iframe 或是 ajax 应用上带来不少麻烦。

简单说来，只有当协议，域名，端口相同的时候才算是同一个域名，否则均认为需要做跨域的处理。

```
之所以有同源策略 我认为其中一个重要原因就是对cookie的保护

cookie 中存着sessionID 。黑客一旦获取了sessionID 并且在有效期内 就可以登录

这里我们可以简单的认为sessionID 全等于 账户加密码

想想当我们访问了一个恶意网站 如果没有同源策略 那么这个网站就能通过js 访问document.cookie 得到用户关于的各个网站的sessionID 其中可能有银行网站 [http://qq.com](https://link.zhihu.com/?target=http%3A//qq.com) github blabla....

通过已经建立好的session连接进行攻击的 这里有一个专有名词 美名曰 CSRF 攻击 题主可以去查 还有需要注意的是同源策略无法完全防御CSRF 这里需要服务端配合

再举个例子，现在我扮演坏人 我通过一个iframe 加载某宝的登录页面 等傻傻的用户登录我的网站的时候 我就把这个页面弹出 用户一看 阿里唉大公司 肯定安全 就屁颠屁颠的输入了密码 注意 如果没有同源策略 我这个恶意网站就能通过dom操作获取到用户输入的值 从而控制该账户
```

**跨域方法**：

1. **JSONP**

JSONP全称为：JSON with Padding，可用于解决主流浏览器的跨域数据访问的问题。Web 页面上调用 js 文件不受浏览器同源策略的影响，所以通过 Script 便签可以进行跨域的请求：

* 首先前端先设置好回调函数，并将其作为 url 的参数。

* 服务端接收到请求后，通过该参数获得回调函数名，并将数据放在参数中将其返回

* 收到结果后因为是 script 标签，所以浏览器会当做是脚本进行运行，从而达到跨域获取数据的目的。
* 优点：
  1. 它不像XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制
  2. 兼容性很好，在古老的浏览器也能很好的运行
  3. 不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果。
* 缺点：
  1. 它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求。
  2. 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题

2. **CORS**

CORS 是一个 W3C 标准，全称是"跨域资源共享"（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 ajax 只能同源使用的限制。CORS 需要浏览器和服务器同时支持才可以生效，对于开发者来说，CORS 通信与同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。

##### **对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个`Origin`字段。** HEAD      GET        POST

##### **非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。**

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

**"预检"**请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。

除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

**（1）Access-Control-Request-Method**

该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是`PUT`。

**（2）Access-Control-Request-Headers**

该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。



**返回的常见头部字段**

**（1）Access-Control-Allow-Origin**

该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

**（2）Access-Control-Allow-Credentials**

该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为`true`，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。

**（3）Access-Control-Expose-Headers**

该字段可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。

**（4）Access-Control-Allow-Methods**

（必含） – 这是对预请求当中Access-Control-Request-Method的回复，这一回复将是一个以逗号分隔的列表。尽管客户端或许只请求某一方法，但服务端仍然可以返回所有允许的方法，以便客户端将其缓存。
**（5）Access-Control-Allow-Headers**

（当预请求中包含Access-Control-Request-Headers时必须包含） – 这是对预请求当中Access-Control-Request-Headers的回复，和上面一样是以逗号分隔的列表，可以返回所有支持的头部。



3.  **Server Proxy**

服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。



4. **location.hash**

在 url 中，`http://www.baidu.com#helloworld` 的 "#helloworld" 就是 location.hash，改变 hash 值不会导致页面刷新，所以可以利用 hash 值来进行数据的传递，当然数据量是有限的。

假设 localhost:8080 下有文件 cs1.html 要和 localhost:8081 下的 cs2.html 传递消息，cs1.html 首先创建一个隐藏的 iframe，iframe 的 src 指向 localhost:8081/cs2.html，这时的 hash 值就可以做参数传递。

缺点：

1. 数据直接暴露在了 url 中
2. 数据容量和类型都有限等等



5. **window.name**

window.name的值不是一个普通的全局变量，而是当前窗口的名字，window.name 属性的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。

例如：`http://localhost:8080/a.html` 在请求远端服务器 `http://localhost:8081/b.html`的数据，我们可以在该页面下新建一个 iframe，该 iframe 的 src 属性指向服务器地址，(利用 iframe 标签的跨域能力)，服务器文件 b.html 设置好 window.name 的值。

但是由于 a.html 页面和该页面 iframe 的 src 如果不同源的话，则无法操作 iframe 里的任何东西，所以就取不到 iframe 的 name 值，所以我们需要在 b.html 加载完后重新换个 src 去指向一个同源的 html 文件，或者设置成 'about:blank;' 都行，这时候我只要在 a.html 相同目录下新建一个 c.html 的空页面并指向它即可。

6. **postMessage**

postMessage 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能，使用起来也特别简单。

创建一个 iframe，使用 iframe 的一个方法 postMessage 可以向`http://localhost:8081/b.html`发送消息，然后通过绑定window的message事件来监听发送跨文档消息传输内容。

**postMessage函数**接收两个参数：第一个为将要发送的消息，第二个为目标窗口的源。

*注：只有当目标窗口的源与postMessage函数中传入的源参数值匹配时，才能接收到消息。*

**message事件**监听函数接收一个参数，Event对象实例，该对象有三个属性：

- data 发送的具体消息
- origin 发送消息源
- source 发送消息窗口的window对象引用


