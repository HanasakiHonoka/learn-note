## **水土保持项目**

### **上传文件**

上传文件格式：multipart/form-data

#### 一个 HTML 表单中的 enctype 有三种类型

- application/x-www-urlencoded
- multipart/form-data
- text-plain

默认情况下是 `application/x-www-urlencoded`，当表单使用 POST 请求时，数据会被以 x-www-urlencoded 方式编码到 Body 中来传送，
 而如果 GET 请求，则是附在 url 链接后面来发送。

GET 请求只支持 ASCII 字符集，因此，如果我们要发送更大字符集的内容，我们应使用 POST 请求。

#### 注意

`"application/x-www-form-urlencoded"` 编码的格式是 ASCII，如果 form 中传递的是二进制等 Media Type 类型的数据，那么 `application/x-www-form-urlencoded` 会把其编码转换成 ASCII 类型。对于 1 个 non-ASCII 字符，它需要用 3 个 ASCII字符来表示，如果要发送大量的二进制数据（non-ASCII），`"application/x-www-form-urlencoded"` 显然是低效的。因此，这种情况下，应该使用 `"multipart/form-data"` 格式（向服务器发送二进制数据）。

### **下载文件**

```js
downloadT() {
      if (!this.createForm.recordId) {
        this.$message.warning("请选择模版类型");
      } else {
        getTemplate(this.createForm.recordId).then((response) => {
          // 创建隐藏的可下载链接
          let content = response;
          let elink = document.createElement("a");
          let name = null;
          for (let i in this.tableList) {
            if (this.tableList[i].value == this.createForm.recordId) {
              name = this.tableList[i].label;
            }
          }
          elink.download = name + "-" + this.getTimeNow() + ".xlsx";
          elink.style.display = "none";
          // 字符内容转变成blob地址
          let blob = new Blob([content]);
          elink.href = URL.createObjectURL(blob);
          // 触发点击
          document.body.appendChild(elink);
          elink.click();
          // 然后移除
          URL.revokeObjectURL(elink.href);
          document.body.removeChild(elink);
          this.$message({
            type: "success",
            message: "下载成功",
          });
        });
      }
    },
```

### Content-Disposition

在常规的 HTTP 应答中，**`Content-Disposition`** 响应头指示回复的内容该以何种形式展示，是以**内联**的形式（即网页或者页面的一部分），还是以**附件**的形式下载并保存到本地。

在 multipart/form-data 类型的应答消息体中，**`Content-Disposition`** 消息头可以被用在 multipart 消息体的子部分中，用来给出其对应字段的相关信息。各个子部分由在[`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type) 中定义的**分隔符**分隔。用在消息体自身则无实际意义。

#### 作为消息主体中的消息头

在 HTTP 场景中，第一个参数或者是 `inline`（默认值，表示回复中的消息体会以页面的一部分或者整个页面的形式展示），或者是 `attachment`（意味着消息体应该被下载到本地；大多数浏览器会呈现一个“保存为”的对话框，将 `filename` 的值预填为下载后的文件名，假如它存在的话）。

```
Content-Disposition: inline
Content-Disposition: attachment
Content-Disposition: attachment; filename="filename.jpg"
```

#### 作为multipart body中的消息头

在 HTTP 场景中。第一个参数总是固定不变的 `form-data`；附加的参数不区分大小写，并且拥有参数值，参数名与参数值用等号(`'='`)连接，参数值用双引号括起来。参数之间用分号(`';'`)分隔。

```
Content-Disposition: form-data
Content-Disposition: form-data; name="fieldName"
Content-Disposition: form-data; name="fieldName"; filename="filename.jpg"
```

## 动态化项目

### 微信小程序原理

微信小程序的框架包含两部分View视图层、App Service逻辑层，View层用来渲染页面结构，AppService层用来逻辑处理、数据请求、接口调用，它们在两个线程里运行。

视图层使用WebView渲染，逻辑层使用JSCore运行。

视图层和逻辑层通过系统层的JSBridage进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。

### 小程序与普通网页开发的区别

小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。

网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。

网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，如表1-1所示。

表1-1 小程序的运行环境

| **运行环境**     | **逻辑层**     | **渲染层**       |
| :--------------- | :------------- | :--------------- |
| iOS              | JavaScriptCore | WKWebView        |
| 安卓             | V8             | chromium定制内核 |
| 小程序开发者工具 | NWJS           | Chrome WebView   |

![img](https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png)

### 微信小程序页面生命周期

![img](https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png)

### JSBridge
主要是给 JavaScript 提供调用 Native 功能的接口，让混合开发中的前端部分可以方便地使用 Native 的功能（例如：地址位置、摄像头）。
而且 JSBridge 的功能不止调用 Native 功能这么简单宽泛。实际上，JSBridge 就像其名称中的Bridge的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是构建 Native 和非 Native 间消息通信的通道，而且这个通信的通道是双向的。

**JSBridge的实现原理**

JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。

在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：通信调用（Native 与 JS 通信） 和句柄解析调用。



## WebPack

### wepack中loader和plugin的区别

#### 一、从功能作用的角度区分：

1、loader：

     loader从字面的意思理解，是 加载 的意思。
    
      由于webpack 本身只能打包commonjs规范的js文件，所以，针对css，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。
    
      loader虽然是扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域，完成压缩，打包，语言翻译。
    
      loader是运行在NodeJS中。
    
      仅仅只是为了打包，仅仅只是为了打包，仅仅只是为了打包，重要的话说三遍！！！


​       

如：css-loader和style-loader模块是为了打包css的

      babel-loader和babel-core模块时为了把ES6的代码转成ES5
    
      url-loader和file-loader是把图片进行打包的。


​       

2、plugin是做什么的？

    plugin完成的是loader不能完成的功能，这是废话，没有说清楚。
    
    plugin也是为了扩展webpack的功能，但是 plugin 是作用于webpack本身上的。而且plugin不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。
    
    插件可以携带参数，所以在plugins属性传入new实例。

如：

1）针对html文件打包和拷贝（还有很多设置）的插件：html-webpack-plugin。

    不但完成了html文件的拷贝，打包，还给html中自动增加了引入打包后的js文件的代码（<script src=""></script>），还能指明把js文件引入到html文件的底部等等。

具体使用，可以查看：webpack打包（主要是处理html文件），并启动服务器

代码如下：

plugins:[   
        //对html模板进行处理，生成对应的html,引入需要的资源模块
        new HtmlWebpackPlugin({
            template:'./index.html',//模板文件，即需要打包和拷贝到build目录下的html文件
            filename:'index.html',//目标html文件
            chunks:['useperson'],//对应加载的资源,即html文件需要引入的js模块
            inject:true//资源加入到底部，把模块引入到html文件的底部
        })
  ]

 

#### 二、从运行时机的角度区分


 1 . loader运行在打包文件之前（loader为在模块加载时的预处理文件）
 2.  plugins在整个编译周期都起作用。



## 虚拟列表（virtualize-list）

**拟列表是一种根据滚动容器元素的可视区域来渲染长列表数据中某一个部分数据的技术。**

简而言之，虚拟列表指的就是「可视区域渲染」的列表。有三个概念需要了解一下：

- **滚动容器元素**：一般情况下，滚动容器元素是 `window` 对象。然而，我们可以通过布局的方式，在某个页面中任意指定一个或者多个滚动容器元素。只要某个元素能在内部产生横向或者纵向的滚动，那这个元素就是滚动容器元素考虑每个列表项只是渲染一些纯文本。在本文中，只讨论元素的纵向滚动。
- **可滚动区域**：滚动容器元素的内部内容区域。假设有 100 条数据，每个列表项的高度是 50，那么可滚动的区域的高度就是 100 * 50。可滚动区域当前的具体高度值一般可以通过(滚动容器)元素的 `scrollHeight` 属性获取。用户可以通过滚动来改变列表在可视区域的显示部分。
- **可视区域**：滚动容器元素的视觉可见区域。如果容器元素是 `window` 对象，可视区域就是浏览器的视口大小(即[视觉视口](https://link.segmentfault.com/?url=https%3A%2F%2Fuser-images.githubusercontent.com%2F7871813%2F43363609-26e0d164-933b-11e8-85e5-1ec21d5ba398.png))；如果容器元素是某个 `div` 元素，其高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可视区域。

实现虚拟列表就是在处理用户滚动时，要改变列表在可视区域的渲染部分，其具体步骤如下：

- 计算当前可见区域起始数据的 startIndex
- 计算当前可见区域结束数据的 endIndex
- 计算当前可见区域的数据，并渲染到页面中
- 计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上
- 计算 endIndex 对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到列表上

![4VbTfO.png](https://z3.ax1x.com/2021/09/15/4VbTfO.png)

