### 为什么使用消息队列
消息队列主要有如下三个使用场景：解耦、削峰、异步
### 使用消息队列有什么缺点
会使系统可用性降低，面临消息队列宕机等风险
会使系统变的复杂，需要额外考虑消息队列的可用性、不重复消费、可靠传输等问题
### 消息队列如何选型
主流的消息队列有ActiveMQ、RabbitMQ、RocketMQ、Kafka

| 特性 | ActiveMQ | RabbitMQ | RocketMQ | Kafka |
| --- | --- | --- | --- | --- |
| 开发语言 | Java | Erlang | Java | Scala |
| 单机吞吐量 | 万级 | 万级 | 十万级 | 十万级 |
| 时效性 | ms级 | us级 | ms级 | ms级 |
| 可用性 | 高（主从架构） | 高（主从架构） | 非常高（分布式架构） | 非常高（分布式架构） |
| 功能特性 | 产品成熟、文档较多 | 由于是Erlang开发，所以并发性好，时延低，管理界面丰富，社区活跃 | 功能完备，拓展性佳 | 指具备MQ的常规功能，但是吞吐量高，用于大数据的处理 |
### 如何保证消息队列时高可用的
对RabbitMQ，有单机模式、普通集群模式、镜像集群模式。普通集群模式就是在多个机器上启动RabbitMQ实例，但创建的Queue只会放在其中一个RabbitMQ实例中，其他的RabbitMQ实例中之存放QUeue的元信息（如Queue在哪个机器上，Queue中消息的数量等），不存放数据信息。这种方式其实没有实现高可用，当某节点宕机后，别的结点的实例都无法从这里拉去数据。这种集群方式还会额外增加网络传输数据的负担，这样做的好处是用多个机器服务某个queue的读写，提高了吞吐量
镜像集群模式中，创建的queue无论是元数据还是数据信息，都会存储在多个实例中，每次写入信息到queue中，都会像其他的实例里的queue进行消息同步，这样做的坏处是增大了网络负担，并且增大性能消耗，因为需要进行消息同步，同时，没有拓展性可言，因为每个RabbitMQ实例中存放的都是全部的Queue数据。

### kafka 的 ack 机制
request.required.acks 有三个值 0 1 -10:生产者不会等待 broker 的 ack，这个延迟最低但是存储的保证最弱当 server 挂掉的时候就会丢数据1：服务端会等待 ack 值 leader 副本确认接收到消息后发送 ack 但是如果 leader 挂掉后他不确保是否复制完成新 leader 也会导致数据丢失-1：同样在 1 的基础上 服务端会等所有的 follower 的副本受到数据后才会受到 leader 发出的 ack，这样数据不会丢失
