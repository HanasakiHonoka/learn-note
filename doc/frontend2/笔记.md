# HTML
## 状态码
|  状态码   | 缩写  | 意思 | 状态码 | 缩写| 意思
|  ----  | ----  | ---- |----  | ----  | ---- |
| 100  | continue |     | 400 | bad request| 
| 101  | switch protocol ||401| unauthorized| 未认证
| 200 | OK|             | 403|forbidden |拒绝服务，认证后未授权
| 201 | created|        | 404|not found | 请求资源不存在
| 202 | accepted|         |405| method not allow|请求方法被禁止
| 203 | Non-Authoritative Information|  |406 |not acceptable | 请求内容特性无法完成
| 204 | no-content     | |407||需要代理身份认证
| 205 | reset |         |408|timeout|
| 206 | patial |        |409| conflict|
| 300 | multiple choices|  |410| gone|
| 301 | moved permanent| 永久移动
| 302 | found| 临时移动
| 303 | see other |
| 304 | no modified |
| 305 | use proxy| 使用代理          | 500| intern server error | 
| 307 | temporary redirect| 临时移动，get请求 |501| not implement|服务器暂不支持请求的功能


# CSS
## BFC(Block Formatting Context)块级格式化上下文

布局模式的流动模型。
决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。具有BFC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。

**BFC的原理（渲染规则）**

BFC元素垂直方向的边距会发生重叠。<br>
属于不同BFC外边距不会发生重叠<br>
BFC的区域不会与浮动元素的布局重叠。<br>
BFC元素是一个独立的容器，外面的元素不会影响里面的元素。里面的元素也不会影响外面的元素。<br>
计算BFC高度的时候，浮动元素也会参与计算(清除浮动)

**如何创建BFC**

- overflow不为visible;
- float的值不为none；
- position的值不为static或relative；
- display属性为inline-blocks,table,table-cell,table-caption,flex,inline-flex;
- body根元素

**作用：**

1. 阻止外边距折叠<br>
将两个div分别置于一个div container中 {overflow： hidden} （非visible）
2. 包含浮动元素 （清除浮动）<br>
高度塌陷问题，在通常情况下父元素的高度会被子元素撑开，而在这里因为其子元素为浮动元素所以父元素发生了高度坍塌，上下边界重合，这时就可以用BFC来清除浮动了
子元素是浮动的，给父元素添加overflow：hiiden来产生bfc
3. 阻止元素被浮动元素覆盖<br>
两个div 其中第一个是浮动的， 第二个会被遮挡，可以领第二个元素添加overflow：hidden变为 BFC来解决



## POSITION 定位技术
静态定位(Static positioning)<br>
是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。<br>

相对定位(Relative positioning)<br>
允许我们相对于元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计(design pinpointing)非常有用。
【正常位置移动相对位置】<br>

绝对定位(Absolute positioning)<br>
将元素完全从页面的正常布局流(normal layout flow)中移出，类似将它单独放在一个图层中。我们可以将元素相对于页面的 <html> 元素边缘固定，或者相对于该元素的最近被定位祖先元素(nearest positioned ancestor element)。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。
【从原始布局中脱离出来，定位到父元素任何位置】

absolute要跟着父元素走，父元素没有显性定义，则默认static。绝对定位元素会包含在初始块<br>

固定定位(Fixed positioning)<br>
与绝对定位非常类似，但是它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。 这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。
【脱离处理 固定视口：  可以做导航 后移动到最顶上】

粘性定位(Sticky positioning)<br>
是一种新的定位方式，它会让元素先保持和position: static一样的定位，当它的相对视口位置(offset from the viewport)达到某一个预设值时，他就会像position: fixed一样定位。
【先保持绝对地址，当视口包含后，固定位置】加上top=0

### 总结
1. Absolute：绝对定位，是相对于最近的且不是static定位的父元素来定位
2. Fixed：绝对定位，是相对于浏览器窗口来定位的，是固定的，不会跟屏幕一起滚动。
3. Relative：相对定位，是相对于其原本的位置来定位的。
4. Static：默认值，没有定位。
5. sticky： 当滑动到后固定



# JavaScript 

JS工具：
1. 包管理： yarn, JSPM, npm, Bower
2. 模块加载器
(项目按需从服务器获取模块，而不是一次性加载所有模块或包含所有模块的JS文件：<br> Systemjs(支持AMD、
CommonJS、UMD 和 ES6）， Requirejs
3. 模块打包器（将任意格式、任意数量的模块合并为一个或多个文件，供客户端加载）：<br>
   webpack、 JSPM、Browserify、Rollup
4. 编译/转译工具及静态类型系统：<br>
   Babel、Google Closure Compiler、CoffeeScript 、TypeScript、Flow
5. 


## 背包问题
`dp[i][j] 表示使用goods[0...i]，最大装j重量的加值`
<br>0/1问题上：<br>
`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weigth[i]] + values[i]) `
<br>无限：<br>
`dp[i][j] = max(dp[i-1][j], dp[i][j-weigth[i]] + values[i]) `

https://leetcode-cn.com/problems/coin-change/
https://leetcode-cn.com/problems/partition-equal-subset-sum/
https://leetcode-cn.com/problems/target-sum/
https://leetcode-cn.com/problems/coin-lcci/

## JS数据类型
值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。

引用数据类型：对象(Object)、数组(Array)、函数(Function)。
|数据类型| String|Number|Boolean|Null|Undefined|
|--|--|--|--|--|--|
|typeof结果|'string'|'number'|'boolean'|'object'| 'undefined'|
|**数据类型**|**Symbol**|**Object**|**Function**|**Array**|
|typeof结果|'symbol'| 'object' | 'function'| 'object'|
|**其他**|**Nan**|****|****|****|
|typeof结果|'number'| '' | ''| ''|

ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名
Symbol 作为对象属性名时不能用.运算符，要用方括号。因为.运算符后面是字符串，所以取到的是字符串 sy 属性，而不是 Symbol 值 sy 属性。

### forEach
```Array.prototype.forEach()```
对数组的每个元素执行一次给定的函数

### Splice
```Array.prototype.splice()```
方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。
```array.splice(start[, deleteCount[, item1[, item2[, ...]]]])```
start 起始位0
deleteCount删除数量
item1,2,3,4...替换的值

### undefined null区别

## shadow-root下元素访问
`document.querySelector("#id").shadowRoot.childnode[num]`



## Instanceof 和typeof实现原理
typeof 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object <br>
js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息<br>
000：对象 <br>
010：浮点数 <br>
100：字符串<br>
110：布尔<br>
1：整数<br>
null 所有机器码均为0  typeof显示 object  instanceof报错<br> 
undefined 用-2^30整数表示<br> 

判断变量类型<br> 
1. ```Object.prototype.toString.call(var)```


2. instanceof 主要的作用就是判断一个实例是否属于某种类型 
也可以判断一个实例是否是其父类型或者祖先类型的实例。

看 a instanceof  b是否成立， 顺着原型链，a._proto_ 是否可以找到对方原型
```js
function instanceof1(left, right){
  right = right.prototype;
  left = left.__proto__;
  while(true){
    if(left==null) return false;
    if(left === right) return true;
    left = left.__proto__;
  }
}
```


## this
this就是属性或方法“当前”所在的对象。
**全局环境**<br>
指window

**构造函数**<br>
指实例对象

**对象方法**<br>
方法运行时的对象
```js
var obj ={
  foo: function () {
    console.log(this);
  }
};
// 情况一
(obj.foo = obj.foo)() // window
// 情况二
(false || obj.foo)() // window
// 情况三
(1, obj.foo)() // window
```
JS引擎内部，obj对象创建时，先在内存中保存函数，函数的地址赋值给foo属性的value属性。 obj和obj.foo存储在两个内存地址，称为地址1和地址2。obj.foo()是地址1调用地址2，因此地址二的运行环境是地址1。<br>
上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境

```js
var a = {
  b: {
    m: function() {
      console.log(this.p);
    },
    p: 'Hello'
  }
};

var hello = a.b.m;
hello() // undefined
```
此时this指向最外层window

采用严格模式，这时内部的this一旦指向顶层对象，就会报错

### 改变this指向
```func.call(thisValue, arg1, arg2, ...)```
没有参数，或者参数为null或undefined，则等同于指向全局对象.

```func.apply(thisValue, [arg1, arg2, ...])```
设为null或undefined，则等同于指定全局对象

```bind```
bind()方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window

https://wangdoc.com/javascript/oop/this.html


## 柯里化 (Currying)
将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术
参数复用。本质上是降低通用性，提高适用性

sub_curry 的作用就是用函数包裹原函数，然后给原函数传入之前的参数，当执行 fn0(...)(...) 的时候，执行包裹函数，返回原函数，然后再调用 sub_curry 再包裹原函数，然后将新的参数混合旧的参数再传入原函数，直到函数参数的数目达到要求为止。


```js
function sub_curry(fn){
	let preargs = [].slice.call(arguments,1);
	return function(){
		return fn.apply(this, preargs.concat(Array.prototype.slice.call(arguments)));
	};
}// 可以处理创建时没有输入全部参数的情况

function curry(fn, length){
	length = length || fn.length;
	let slice = Array.prototype.slice;
	return function(){
		if(arguments.length<length){
			let combined = [fn].concat(slice.call(arguments));
			return curry(sub_curry.apply(this, combined), length-arguments.length);
//将参数一个个输入，每次只有把它链接起来，直到所有的长度参数都包含了，调用apply赋予当前的对象累加的匿名函数并执行
		}else{
			return fn.apply(this, arguments);
		}
	};
}
```
另一种写法
```js
function curry(fn, args){
    let length = fn.length;
    arg = args || [];
    return function(){
        let _args = arg.slice(0),i;
        for(i=0; i<arguments.length; i++){
            _args.push(arguments[i]);
        }
        if(_args.length<length){
            return curry.call(this, fn, _args);
        }else{
            return fn.apply(this, _args);
        }
    };
}
```
考虑fun(1,_)(3) 占位符情况
https://github.com/mqyqingfeng/Blog/issues/42


## 函数提升和变量提升

## 浏览器中输入url后的过程

## HTTP缓存

## 事件

### 事件捕获，事件冒泡

```javascript
addEventListener("click", (event) => {
    alert("我是p元素的上层元素");
    // p元素的click事件没有向上冒泡，该函数不会被执行
}, true);  //true在事件捕获阶段
```


```event.preventDefault()```<br>
如果此事件没有被显式处理，它默认的动作也不应该照常执行。此事件还是继续传播，除非碰到事件侦听器调用stopPropagation() 或stopImmediatePropagation()，才停止传播。

```event.stopPropagation()```<br>
阻止事件在捕获和冒泡阶段进一步传播, 但同级的后续事件依然可以执行

```event.stopImmediatePropagation()```<br>
如果多个事件监听器被附加到相同元素的相同事件类型上，当此事件触发时，它们会按其被添加的顺序被调用。如果在其中一个事件监听器中执行 stopImmediatePropagation() ，那么剩下的事件监听器都不会被调用。


## 内存泄漏

浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

### 强制缓存
就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。查询有三种结果：<br>
1. 无缓存结果和缓存标识，直接向服务器发请求
2. 存在结果和标识但失效，发协商请求
3. 存在且未失效，直接返回。
   
服务器的响应报文中，缓存规则控制强制缓存的字段分别是Expires和Cache-Control，
前者是时间，后者优先级更高：类型有
- public  客户端，代理服务器都缓存
- private 客户端缓存
- no-cache:  客户端缓存内存，是否缓存需要协商缓存验证决定
- nos-store：不缓存
- max-age=xxx     缓存内容xxx秒后失效

**内存缓存**(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：         
         
- 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。         
- 时效性：一旦该进程关闭，则该进程的内存则会清空。         
         
 **硬盘缓存**(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢.js 图片会使用内存缓存， css则硬盘缓存

### 协商缓存
两种结果
1. 协商缓存生效，返回304
2. 失效 返回200 和请求结果
   
控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间
If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器会对此作比较。 若最新修改时间> last-modified 重新返回资源和200；否则304

Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值
服务器比较etag 若一致发牛304 否则200和新资源





## 原型链
主线程包含堆和栈。<br>
（顺带一提：其中变量是基本数据类型会存在栈中，如Number, String, Boolean, null, undefined; 另外Array, Object，Function则是引用传递，他们的地址存在堆中，详细内容可以查看[JS数据类型](#js数据类型))

 函数的执行会产生执行上下文，主线程使用执行上下文栈管理执行上下文，过程就是入栈和出栈。执行上下文组成分为三部分：
 - [变量对象VO](#变量对象)
 - [作用域链](#作用域链)
 - [this](#this)

### 变量对象

执行上下文的处理过程分为：
1. 进入执行上下文（活动对象AO处理）
2. 代码执行

函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。
活动对象包括：函数形参，函数声明（执行上下文内的函数），变量声明。
这一步会涉及[函数提升，变量提升](#函数提升和变量提升)。
<br>举例来说:
```javascript
function foo(a){
    let b = 2;
    function c(){};
    let d = fucntion(){};
    b = 3;
}
foo(1);
```
当执行上下文时，产生的AO如下
```javascript
AO = {
    arguments:{
        0:1,
        length:1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```
代码执行后的AO如下
```javascript
AO = {
    arguments:{
        0:1,
        length:1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```
**阶段总结：变量对象的创建过程**
1. 全局上下文的变量对象初始化是全局对象
2. 函数上下文的变量对象初始化只包括 Arguments 对象
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
4. 在代码执行阶段，会再次修改变量对象的属性值

### 作用域链
函数的作用域在函数定义的时候就决定了.
函数有一个属性[[scope]], 当函数创建时，会保存父变量对象到其中，可以理解为 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！
```javascript
function foo() {
    function bar() {
        ...
    }
}
```
**函数创建**时各自的[[scope]]为：
```javascript
foo.[[scope]] = [
  globalContext.VO
];

bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];
```
**函数激活**
当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。

这时候执行上下文的作用域链，我们命名为 Scope：
```javascript
Scope = [AO].concat([[Scope]]);
```
至此，作用域链创建完毕。
<br>**实例 流程**

```javascript
var scope = "global scope";
function checkscope(){
    var scope2 = 'local scope';
    return scope2;
}
checkscope();
```
1. 这是全局代码，因此主线程会将它压入到执行上下文栈中
```javascript
ECStack = [
    globalContext
]
```
2. 函数checkscope()创建时会保存作用域链到内部属性[[scope]]
```
checkscope.[[scope]]=[
    globalContext.VO
] 
```
3. 开始执行checkscope()，首先[1]创建执行上下文，并压入栈中
```
ECStack = [
    checkscopeContext,
    globalContext
]
```
4. 给执行上下文checkscopeContext: [2]初始化Scope属性作用域链
```
checkscopeContext = {
    Scope: checkscope.[[scope]]
}
```   
5. 给执行上下文checkscopeContext:[3]初始化活动对象AO
```
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    }，
    Scope: checkscope.[[scope]],
}
```
6. [3]将活动对象压入checkscope作用域链
```
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: [AO, [[Scope]]]
}
```
7. 准备工作完成，开始函数代码执行，AO属性更改
```
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: 'local scope'
    },
    Scope: [AO, [[Scope]]]
}
```
8. 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出
```
ECStack = [
    globalContext
];
```

### this  未完成

# 网页性能

## RAIL模型
- Respones： 50ms完成，100ms内响应用户的输入
- Animation： 10ms 1帧
- Idle： 中间空间50ms内能交互，最大化主线程的空闲时间
- Load： 第一次加载5s内，第二次2s内，5s内让网页变得可交互
  <br>**懒加载**

  ```html
  <img loading=lazy>
  ```
  用户滚动到它们之前，可视区域外的图像不会加载.<br>
  原理是先将属性src设空，真实路径存data-original属性中，页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。

### 分析RAIL用的工具
- Chrome DevTools
- Lighthouse
- WebPageTest

## 前端性能优化
1. [缓存](#缓存)
2. [发送请求](#发送请求)
3. [服务端响应](#服务端响应)
4. [页面解析与处理](#页面解析与处理)
5. [页面静态资源](#页面静态资源)
6. [运行时](#运行时)
7. [预加载](#预加载)

### 缓存
以下缓存内容可以理解为递进的
- 本地数据存储<br>
  在业务代码侧进行缓存处理。缓存方式包括 localStorage、sessionStorage、indexedDB
- 内存缓存<br>
  存活时间短，chrome为5min，浏览器关闭清空
- Cache API
  <br>当内存缓存未命中，会使用Cache API，配合Service Worker使用。<br>Cache API 提供的缓存可以认为是“永久性”的，关闭浏览器或离开页面之后，下次再访问仍然可以使用。
- [HTTP 缓存](#HTTP缓存)<br>
  - 强制缓存(包含字段 HTTP1.0 Expire, HTTP1.1 Cache-Control)
  - 协商缓存(包含字段 Last-modified/if-modified-sinse、Etag/if-match-none )
- Push Cache<br>
缓存检查.Push Cache 其实是 HTTP/2 的 Push 功能所带来的。简言之，过去一个 HTTP 的请求连接只能传输一个资源，而现在你在请求一个资源的同时，服务端可以为你“推送”一些其他资源 —— 你可能在在不久的将来就会用到一些资源 

### 发送请求
1. 避免多余重定向<br>
   服务迁移导致修改url; 登录场景可能也涉及重定向。<br>
   重定向分为 301 的永久重定向和 302 的临时重定向。建议贴合语义，例如服务迁移的情况下，使用 301 重定向。 每次重定向都需要请求，减少请求次数
2. DNS预解析
   DNS解析流程可能很长，耗时高。具体过程可以参考[浏览器中输入url后的过程](#浏览器中输入url后的过程)。<br>
   DNS Prefetch 就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 yourwebsite.com 上下载一个资源啦，帮我先解析一下域名吧。浏览器会根据当前的网络、负载等状况做决定。

   ```html
   <link rel="dns-prefetch" href="//yourwebsite.com">
   ```
3. 预先建立连接<br>
   使用 Preconnect[3] 可以帮助你告诉浏览器：“我有一些资源会用到某个源（origin），你可以帮我预先建立连接。与 DNS Prefetch 类似，浏览器可以视情况完成部分工作。浏览器对此的处理：
   1. 首先，解析 Preconnect 的 url；
   2. 其次，根据当前 link 元素中的属性进行 cors 的设置；
   3. 然后，默认先将 credential 设为 true，如果 cors 为 Anonymous 并且存在跨域，则将 credential 置为 false；
   4. 最后，进行连接   
    ```html
    <link rel="preconnect" href="//sample.com">
    //或者
    <link rel="preconnect" href="//sample.com" crossorigin>
    ```
4. 使用CDN(Content Delivery Network, 内容发布网络)<br>
   静态资源，我们可以考虑通过 CDN 来降低时延。(网络传输有极限，近服务器好)<br>
   CDN 本身有缓存功能，把那些网页里一成不变的内容，例如图片、音乐、视频等，都分发并缓存到了各个 CDN 服务节点上。<br>
   对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。
   ![发送请求的流程](./images/发送请求的流程.png)
   <center>发送请求的流程

### 服务端响应
1. 使用流响应<br>
   现代浏览器都支持根据流的返回形式来逐步进行页面内容的解析、处理
   [CSS-Only Chat](https://github.com/alienzhou/css-only-chat-node) 不用任何 JS 的异步 Web 聊天组件
2. 业务聚合
3. 避免代码问题
- async await 的不当使用导致并行请求被串行化了；
- 频繁地 JSON.parse 和 JSON.stringify 大对象；
- 正则表达式的灾难性回溯；
- 闭包导致的内存泄漏；
- CPU 密集型任务导致事件循环 delay 严重；
- 未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，这种频繁的启停也会比较消耗资源；
### 页面解析与处理
通过对资源加载顺序和脚本加载的控制，避免了无谓的阻塞，优化了解析性能
1. 资源在页面的位置<br>
   JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又回阻塞 JavaScript 的执行。
所以这就是为什么在优化的最佳实践中，我们基本都推荐把 CSS 样式表放在 <head> 之中（即页面的头部），把 JavaScript 脚本放在 <body> 的最后（即页面的尾部）
2. 使用defer和async<br>
   defer 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 async 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。
根据它们的特点，推荐在一些与主业务无关的 JavaScript 脚本上使用 async。例如统计脚本、监控脚本、广告脚本等。这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制
3. 页面文档压缩<br>
   HTML 的文档大小也会极大影响响应体下载的时间。一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩
   
### 页面静态资源
- 减少不必要的请求
    - 对于不需要使用的内容，其实不需要请求，否则相当于做了无用功；
    - 对于可以延迟加载的内容，不必要现在就立刻加载，最好就在需要使用之前再加载；
    - 对于可以合并的资源，进行资源合并也是一种方法
- 减少包体大小
  - 使用适合当前资源的压缩技术；
  - 避免再响应包体里“塞入”一些不需要的内容
- 降低应用资源时的消耗
- 利用缓存<br>
  
**具体静态资源各自处理方式**

**JS**

一.减少不必要请求 
  1. 代码拆分，按需加载 
  2. 代码合并。 将一些 common 库或 npm 依赖进行打包合并。流行的构建工具中（webpack/Rollup/Parcel），是默认会帮你把依赖打包到一起的
   
二.减少包体大小(下载耗时)
  1. 代码压缩<br>
   使用 UglifyJS 做源码级别的压缩。它会通过将变量替换为短命名、去掉多余的换行符等方式，在尽量不改变源码逻辑的情况下，做到代码体积的压缩
   2. Tree Shaking<br>
   检测源码中不会被使用到的部分，将其删除，
   3. 优化 polyfill 的使用<br>
   新特性对应的 polyfill，用于在非兼容浏览器上也能使用新特性的 API。polyfill 最优的使用方式应该是根据浏览器特性来分发，同一个项目在不同的浏览器，会加载不同的 polyfill 文件
   4. webpack<br>
   webpack 现在已经成为很多前端应用的构建工具，因此这里单独将其列了出来。我们可以通过 webpack-bundle-analyzer 这个工具来查看打包代码里面各个模块的占用大小

三.解析耗时
1. js解析耗时<br>
   需要考虑去掉不必要的代码。（非运行的代码也需要解析和编译）; JavaScript 的解析、编译和执行会阻塞页面解析，延迟用户交互
2. 避免long task<br>
3. 简单页面制作可以不依赖于框架

四.缓存
1. 发布与部署
2. 基础库代码打包合并。<br>利用缓存减少新版本发布后用户的访问速度。这种方法本质上是将缓存周期不同的内容分离了，隔离了变化
3. 减少webpack编译不当导致的缓存失效
   - 使用hash代替自增id
   - 将 runtime chunk 单独拆分出来<br>
  通过 optimization.runtimeChunk 配置可以让 webpack 把包含 manifest 的 runtime 部分单独分离出来，这样就可以尽可能限制变动影响的文件范围
  - 使用 records

**CSS**<BR>
1. 关键渲染路径（Critical Rendering Path，即 CRP）.<BR>
CRP 是指优先显示与当前用户操作有关的内容。由于 CSS 会“间接”阻塞页面的解析，所以在这个过程中的 CSS 也被称为关键 CSS。识别出当前业务中的关键 CSS，优先下载与解析它，将会帮助我们更好降低延迟。
2. 优化资源请求<br>
   按需加载 | 合并文件 | 请求优先级顺序 | 慎用@import（解析对应的css才能串行请求后面的内容） | js位置
3. 减少包体大小
   压缩 | 选择合适兼容性
4. 解析和渲染树构建
   - 简化选择器
   - 避免昂贵属性：border-radius | box-shadow | opacity | transform | filter | position: fixed
   - 使用先进布局
5. 利用缓存

**图片**
1. 优化请求数
   - 雪碧图sprite（多个小图标）<br>
  不同的图标元素都会将 background-url 设置为合并后的雪碧图的 uri；
不同的图标通过设置对应的 background-position 来展示大图中对应的图标部分。
   - 懒加载<br>  尽量只加载用户正在浏览或者即将会浏览到的图片<br>
   首屏可以不需要懒加载，对首屏图片也使用懒加载会延迟图片的展示。
设置合理的占位图，避免图片加载后的页面“抖动”。
虽然目前基本所有用户都不会禁用 JavaScript，但还是建议做一些 JavaScript 不可用时的 backup 
   - css 图片懒加载  最常见的场景就是 ```background-url```
   - 内联base<br>
    还有一种方式是将图片转为 base64 字符串，并将其内联到页面中返回，即将原 url 的值替换为 base64。这样，当浏览器解析到这个的图片 url 时，就不会去请求并下载图片，直接解析 base64 字符串即可.
    <br>缺点：变成 base64 后体积会增大 33%.可能并行加载的图片信息，都会被放在页面请求中（像当于是串行了）同时这种方式也不利于复用独立的文件缓存。所以，使用 base64 需要权衡，常用于首屏加载 CRP 或者骨架图上的一些小图标
2. 减小图片大小 
 - 选择合适格式
     - 使用  WebP 有损和无损压缩都比传统（jpg、png）小 
     - SVG  缩放和高保真
     - video 替代 GIF。通过静音（muted）的 video 。vedio比gif小5-20倍
     - 渐进式JPEG   传统基线是从上到下渲染， 渐进则是由模糊到细致，体验更好<br>
    不过渐进式 JPEG 的解码速度会慢于基线 JPEG，所以还是需要综合考虑 CPU、网络等情况，在实际的用户体验之上做权衡。
- 图片质量权衡
     - 图片压缩可以使用imagemin工具
     - 合适大小和分辨率
        ```HTML
        <img srcset="small.jpg 480w, large.jpg 1080w" sizes="50w" src="large.jpg">
        ```
     - 用[imageOptim](https://imageoptim.com/api)删除冗余信息```<meta>```
     - SVG压缩 <br>SVG 作为一种 XML 文本，同样是适合使用 gzip 压缩的
-- 缓存策略

**字体**
1. font-display<br>
    在 @font-face 中设置 font-display: swap，他可以让 FOIT 的默认行为变为 FOUT (Flash of Unstyled Text)，即先会使用默认字体样式展示文本，字体加载完毕后再将文本的字体样式进行替换. 目前兼容性一般

   ```css
   @font-face {
    font-family: 'Samplefont';
    src: url(/static/samplefont.woff2) format('woff2'),
         url(/static/samplefont.woff) format('woff');
    font-display: swap;
    }
    ```
2. 内联字体   
    字体也能像图片那样转化为base64的字符串。设置到 @font-face 里的 src 属性上：
    ```css
    @font-face {
    font-family: 'Samplefont';
    src: url('data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAHyoABMAAAAA4XQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABG…') format('woff2');
    }
    ```
    缺点：@font-face中只能加载一种字体类型，要加载其他的需要额外请求。
3. 使用CSS Font Loading API
4. FOFT<br>
    在需要加载同一字体的粗体、斜体时，FOFT (Flash of Faux Text) 方法会非常有效。

**视频**
1. 使用合适格式<br>
    除了 MPEG-4 之外，还支持一种叫 WebM 的新的视频格式.
2. 视频压缩
3. 移除不必要音轨
4. 使用流
    浏览器使用“流”或者小分片的方式来播放你的视频
5. 移除不必要的视频<br>
    对于不需要使用视频的场景，最好的优化方法就是去掉视频。例如在小屏幕上，你可以通过媒体查询来避免下载视频   
    ```css
    @media screen and (max-width: 650px) {
        #hero-video {
            display: none;
        }
    }
    ``` 

### 运行时
1. 注意强制同步布局
2. 长列表优化
3. 避免JS运行时间过长
4. 善用Composite
5. 滚动事件性能优化
    - 节流
    - 去抖
6. Passive event listeners


### 预加载
1. 预加载技术
    <br>prefetch
    <br>prerender
    <br>preload
    <br>webpack
    基于 JavaScript 的预加载
2. 视频预加载
    - 视频添加```preload```属性<br>
    ```poster```属性设置视频下载时或用户点击播放按钮前播放器上显示的图像```meta```载入元数据（时长、尺寸、文字轨道）
    - 使用preload link
    - 使用 JavaScript 进行自定义的 Buffer 操作<br>
    可以通过 HTTP Range 请求头来获取开始的一小段视频数据，然后使用 MediaSource API 来进行视频媒体数据的暂存与播放
3. 预加载策略

    预加载资源过多，可能导致流量消耗过大，占用正常请求的通道；
    预加载资源过少，可能导致覆盖率太低，对于大部分资源用户无法享受到预加载效果
    1. quicklink<br>
    quicklink 是 GoogleChromeLabs 推出的轻量级库，使用 Resource Hints 进行预加载，对于不支持的浏览器会回退到 XHR 模式。它的策略其实非常直接，核心就是当链接进入到视口后，会对其进行预加载。

    当然我们还可以加一些其他策略，例如设定一个 200ms 的停留阈值。总体而言，它的策略还是比较简单的，更像是为前端预加载提供一个思路。如果感兴趣，可以从这篇文章中了解 quicklink 的实现细节[6]。

    2. Guess.js<br>
    Guess.js 则是一个更为完备的工具包。它会结合前端访问与打点的数据进行统计，甚至应用一些机器学习的模型，来提供一个更精细化、更准确的预加载策略。同时，在预加载之外，它还可以帮助实现最优的打包方式、加载路径等。核心就是通过大量的实际用户数据，来帮助前端性能优化做决策与预测。

# VUE入门笔记
Vue.js通过MVVM模式拆分视图和数据两部分，将其分离。

创建Vue对象实例，通常结构为
```javascript
var app = new Vue({
    el: '#app',  //用于指定页面一个已存在的DOM元素挂载VUE实例
    data: {
        name: ''
    }
})
```
### VUE生命周期 [有疑问： 每秒显示的时间vue实例会一直调用？]
- created <br>  Vue实例创建完成后调用，此时尚未挂载，$el不可用
- mounted <br> el挂载到实例后调用，一般第一个业务逻辑从这开始。
- beforeDestory <br> 实例销毁前调用，通常用来解绑一些监听事件（ps：可以用来解决[内存泄漏](#内存泄漏)的问题）

## Vue核心理念为  数据驱动DOM

### v-model
实现表单输入和应用状态之间的双向绑定<br>
```<input type="text" v-model="parentMessage">```
可以通过组件的```this.$emit('input', this.value)```来改变```v-model```绑定的值

### v-bind
用于动态更新HTML元素上属性 ，有语法糖```v-bind:attr="xx"``` 可以缩写为```:attr="xx"```

### v-on
用来绑定事件监听器.  有语法糖```v-on:click="hanle"``` 可以缩写为```@click="handle"```
```@xx```后的值可用通过组件的```this.$emit('xx',this.value);```触发来携带数据实现组建通信

v-if 绑定的元素若值为false则移除

```html
<div id="app">
    <a v-bind:src="url">连接</a>
    <p v-if="show">这是一段文本</p>
    <button v-on:onclick="handleClose">点击隐藏</button>
</div>
<script>
    new Vue({
        el: "#app",
        data:{
            url: 'www.baidu.com'
        },
        methods:{
            handleClose: function(){
                this.show = false;
            }
        }
    })
</script>
```

计算属性默认是get，可以用来计算变量值
直接的methods也能实现相同的get功能，但是method是每次重新渲染就会调用。而计算属性是变化了才调用。
<br>是计算属性还是methods取决于是否使用缓存，当遍历大数组和大量计算用计算属性

在开发过程中。写复用组件时，如果设置类名的表达式较长或逻辑复杂，尽可能优先使用计算属性

## VUE内置指令
### v-cloak
不需要表达式，会在VUE实例结束编译时从绑定的html元素上移除，经常与dispaly:none配合使用。
```css
[v-cloak]{
    display: none;
}
```
适用于解决初始化慢导致页面闪动。

### v-once
定义的元素或组件只渲染一次，包括元素或组件子结点。被视为静态内容。
通常在需要进一步优化性能时，可能用到

### 条件渲染指令 
**v-if v-else-if v-else**
使用template 渲染时不会包含
```javascript
<template v-if="var === 1">
    <div>xxx</div>
<template>
```
v-if和v-show区别<br>
v-if 才是真正条件渲染，当初始值是false时，一开始元素/组件不会渲染，只有条件第一次变为真时。才会开始编译；<br>
v-show 只是简单的CSS属性切换，无论条件真否都会编译。
<br> 前者适合条件不经常改变场景，它开销大， 后者适用于频繁切换条件

### v-for
```html
<template v-for="(book, index) in books">
```
### 修饰符
- .stop 阻止事件冒泡
- .prevent 不再重载
- .capture 使用事件捕获模式
- .self 当元素本身（非子元素）时触发
- .once 只触发一次（元素/组件均适用）

```v-model.lazy="message"```
在message失去焦点或按回车时更新

```v-model.number="message"```
将输入转化为Number类型

```v-model.trim="message"```
自动过滤输入的首尾空格

## 组件
组件的目的在于复用。<br>
需要注册组件后使用，组件分全局注册和局部注册。

组件间 父组件通过使用props传递数据给子组件。
```js
Vue.component('my-component',{
    props: ['message'],  // my-component自定义的message属性
    template: '<div>{{{message}}</div>',
    data: function(){
        return {
            var:1
        };
    } 
});
var app = new Vue({
    el: '#app'
})
```
props的数据来自于父组件， data函数return的数据是组件自己的数据，作用域是组件本身。两者都能在template，computed，methods中使用。HTML不区分大小写，使用DOM模块时，需要使用短横分隔命名。

```javasript
<my-component message="[1,2,3]"></my-component>
<my-component :message="[1,2,3]"></my-component>
```
上面两者区别在于第一个是message绑定的是一个字符串 长度=7<br>
第二个动态绑定的是一个数组, 长度=3。

为了使父子组件解耦，可以在子组件中间父组件的数据保存下来，在自己的作用域内随意改变，且不影响父组件。JS中对象和数组是引用类型，指向同一个内存空间，所以props是对象和数组时，子组件内改变也会影响父组件。

### 数据验证
组件数据提供给别人时，推荐进行数据验证，验证type类型可以是：
- String
- Number
- Boolean
- Array
- Object
- Function
- 也可以是自定义构造器，使用instanceof检测。
  
### 组件通信
子组件像父组件传递数据，需要用自定义事件。
<br>通过$emit()触发事件，父组件使用$on()来监听子组件事件。

中央事件总线，子组件通过```bus.$emit('event-name', msg);```传递数据到总线，
总线上的父组件再通过```bus.$on('event-name', function(msg){
    dealt(msg);
})```进行处理。

通过```this.$parent.var``` 可以访问父组件变量， 但不建议这么使用。
通过```this.$children.var``` 可以访问子组件变量， 但不建议这么使用。同时由于序列不固定，因此需要通过索引来找子组件。
```html
<component-a ref="comA"></component-a>
<script>
    var msg = this.$refs.comA.message;
</script>
```
在父组件模板中，子组件标签上使用ref指定一个名称，并在父组件内通过this.$refs来访问指定名称的子组件。

## slot分发内容
```<slot>```若没有使用name特性，它将作为默认slot出现，父组件没使用slot特性的元素都将出现在这里。
```<slot name="header"></slot>```

### 组件高级用法
1. 递归组件  适用于开发未知层级关系的独立组件
2. 内联模板  组件将内容当做模板，而不是把它当内容分发
3. 动态组件  使用```<component :is="comA">```动态挂载不同组件，is特性来选择要挂载的组件。
4. 异步组件  
   ```javascript
    Vue.component('child-component', function(resolve, reject){
        window.setTimeout(function(){
            resolve({
                template: '<div>异步渲染</div>'
            });
        }, 2000);
    })
    var app = new Vue({
        el: '#app'
    })
   ```

### 组件结构
```javascript
   Vue.component('input-number',{
    template:'\
    <div class="input-number">\
    </div>',
    props:{
        
    },
    data:function () {
        return {
            currentValue: this.value,
        }
    },
    watch: {
        currentValue: function(val){
            this.$emit('input', val);
            this.$emit('on-change', val);
        },
        value: function(val){
            this.updateValue(val);
        }
    },
    methods:{
        updateValue: function(val){
            if( val>this.max) val=this.max;
            if(val<this.min) val=this.min;
            this.currentValue = val;
        }

    },
    mounted: function(){
        this.updateValue(this.value);
    }
});

function isValueNumber(value){
    
    return (/(^-?[0-9]+\.{1}\d+$)|(^-?[1-9][0-9]*$)|(^-?0{1}$)/).test(value+'');
}
```
- ```props``` 是父组件传递下来的数据
- ```data``` 是子组件自身的数据，在后续函数中可以通过this.val调用
- ```watch``` 监听的变量在变化后都会运行对应的函数，例如在值在输入框改变后会先引起methods中函数，修改后触发监听
- ```methods``` 函数方法
- ```mounted``` ```created```:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
```mounted```:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作<br>
**注意在引入component.js时位置放在父组件前，这样父组件初始化后能直接通过双向绑定调用mounted！**


## 自定义指令
全局注册
```javascript
Vue.directive('focus',{
    //指令选项
})
```
局部注册
```javascript
var app = new Vue({
    el:'#app',
    directives:{
        focus:{
            //指令选项
        }
    }
})
```

自定义指令由几个钩子行数组成：
- bind <br>只调用一次。指令第一次绑定到元素时调用
- inserted <br>被绑定元素插入父节点时调用
- update <br>被绑定元素所在模板更新时调用，不论绑定值是否变化，通过比较更新前后绑定值，可以忽略不必要的更新
- componentUpdated <br>被绑定元素坐在模板完成一次更新周期时调用
- unbind <br>只调用一次，指令与元素解绑时调用


## Render函数

```createElement```生成Virtual DOM。 虚拟COM本身就是js的对象，用这种方式开支更小，但是可读性不如template好
格式：
```javascript
Vue.component('component-name',{
    ...
    render:function(createElement, context)){
        return createElement('element', {attrs:values} , [innerHTML]);
    }

    //或者
    render(h){
        return h('element',  {attrs:values} , [innerHTML]);
    }

    //template方式
    template:'\
        <element\
            attrs:value>\
            innerHTML\
        </div>\
    '
    ...
})
```
在webpack做编译时，template都会被预编译为render函数

## Webpack
JS应用程序模块打包工具。

SPA 单页面富应用通常由1个HTML文件和一堆按需加载的js组成。
需要先安装```Node.js```、```NPM```包管理工具

建立一个文件夹，依次执行
```
npm init
npm install webpack --save-dev
npm install webpack-dev-server --save-dev
npm install webpack-cli@3 -D //安装3.0版本  需要和另外两个对应上

//添加 package.json的scripts 使能npm run dev 
"scripts":{
    ...
    "dev":"webpack-dev-server --open --config webpack.config.js"
}

npm run dev
```

## 单文件组件
原来的```vue.component()```写法弊端：
- 全局定义 (Global definitions) 强制要求每个 component 中的命名不得重复
- 字符串模板 (String templates) 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 \
- 不支持 CSS (No CSS support) 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏
- 没有构建步骤 (No build step) 限制只能使用 HTML 和 ES5 JavaScript，而不能使用预处理器，如 Pug (formerly Jade) 和 Babel

**单文件组件**<br>
```.vue```
- 完整语法高亮
- CommonJS 模块
- 组件作用域的 CSS

将一个配置文件作为模块导出:

config.js
```javascript
var Config={
    version: '1.0.0'
};
export {Config};
//或者
export var Config={
    version: '1.0.0'
};
```
add.js
```javascript
export function add(a,b){
    return a+b;
}
```
main.js
```JavaScript
import {Config} from './config.js';
import {add} from './add.js';
console.log(Config);
console.log(add(1,1));
```

### CommonJs 和ES6 导入导出 区别 
原来的js引入需要按顺序，否则出错。
这就导致
- 污染全局作用
- 维护成本高
- 依赖关系不明显

   该规范最初是用在服务器端的node的，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块（同步）

https://juejin.cn/post/6844903636108066830#heading-7

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。<br>
CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
 
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。<br>
 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 因此可以更改路径导入代码
 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。

对于模块的依赖，CommonJS是动态的，ES6 Module 是静态的
导入导出.

**ES6**： 命名导出 默认导出
```js
export default show
import show form './B.js'  如果是默认导出 可以随意取名字
show()    //不需要前缀类
导出 
1.export {show, count}
2默认导出
// 命名导出变量count
export let count = 3
// 默认导出函数show 只能一次
export default show
```
 导入需要用一对 {} 大括号来接收我们需要导入的方法或函数  
```js
import {show, count} from './B.js'
show()

import {show as print, count as number} from B'..js/'

import * as bModule form './B.js'
bModule.show();  bModule.count
//导入默认函数
import print from './B.js/'
print()
 ```

**CommonJS:** 每个文件是一个模块。每个模块相互独立。
需要导出需要向外暴露的变量或方法
```js
module.exports={show}
exports.show = show   //另一种写法
const bModule = require('./B.js')
const bModule = require('.'+fileName) //支持表达式参数
bModule.show()
```
当我们执行 exports.变量 或 exports.函数 时，其实就相当于把变量或函数存储到 module.exports 

<hr>
webpack-dev-server热更新，通过简历WebSocket连接来实时响应代码修改。


## 插件
### 前端路由和vue-router
**路由**： 每次```get``` 或者```POST```等请求在服务端有一个专门的正则配置列表，然后匹配到具体的一条路径后，分发到不同的Controller，进行各种操作，最终将html或数据返回给前端，完成一次IO。

**前端路由**: 两种实现
- 利用url的hash，即锚点#，JS通过hashChange事件监听url改变，IE7及以下需要用轮询
- HTML5的History末世，使得url看起来像普通网站那样，以"/"分割，但页面没有跳转，需要服务端支持，在服务端收到请求后，都指向同一个html文件。
  
SPA只有一个html，整个网站所有内容都在一个html里面，通过js处理。
有点：
- 页面持久性，例如音乐网站在播放歌曲同时跳转到别的页面，音乐不中断
- 前后端分离

#### 跳转
vue-router两种跳转页面的方法：
1. 内置的```<router-link>```会被默认渲染为```<a>```
```html
<router-link to='/about' >跳转about</router-link>
```
它有一些常用prop:
- tag 指定渲染为什么标签  例如tag="li" 将不渲染```<a>```而是```<li>```
- replace 不会留下History记录，导航后不能用后退键
- active-class 路由匹配成功时，自动为当前元素设置一个router-link-active的class

2. 使用router实例的方法，通过JS<br>
通过this.$router可以访问当前路由的信息
```html
// about.vue
<template>
    <div>
        <h1>介绍页</h1>
        <button @click="handleRouter">跳转到user</button>
    </div>
</template>
<script>
    export default{
        methods: {
            handleRouter(){
                this.$router.push('/user/123');
            }
        }
    }
</script>
```
另有
```this.$router.replace('/user/123');```
替换掉当前的histary记录<br>
```go```用于前进后退，类似于```window.history.go()```
<br>this.$router.go(-1); // 后退1页

#### SPA中修改标题
通过vue-router 提供的导航钩子beforeEach和afterEach， 在路由即将改变前后触发。 这里设置标题可以在beforeEach钩子完成。
```javascript
const router = new VueRouter(RouterConfig);
router.beforeEach((to, from, next)=>{
    window.document.title = to.meta.title;
    next();
});
```
导航钩子可以实现一些全局功能，便于维护。<br>例如：
滚动页面到某一位置后跳转页面，滚动条默认上一个页面停留位置，可以用导航钩子返回顶端。
```js
//main.js
router.afterEach((to, from, next)=>{
    window.scrollTo(0,0);
});
```
页面校验是否登录，若没有则跳转登录
```js
router.beforeEach((to, from, next)=>{
    if(window.localStorage.getItem('token)){
        next();
    }else{
        next('/login')'
    }
});
```

### Vuex
统一管理组件状态<br>
适用于大型单页应用，适合多人协同开发、

通过store使所有组件都能访问，通过mutations修改store数据。
```js
//main.js
import Vuex form 'Vuex';
Vue.use(Vuex);

const store = new Vuex.Store({
    state:{
        count: 0
    },
    mutations:{
        increment(state, n=2){ //默认加2
            state.count++;
        },
        decrease(state){
            state.count--;
        }
    },
    actions:{
        increment(context){
            return new Promise((resolve)=>{
                setTimeout(()=>{
                    context.comit('increment');
                    resolve();
                }, 1000)
            });
        }
    }
});
new Vue({
    el: '#app',
    router: router,
    store: store,
    render(h){
        return h(App)
    }
});
```
组件通过```$store```可以全局访问store，<br> 
```this.$store.commit('increment');```触发mutations的内容，它看起来就像观察者模式，组件负责提交事件名，Vuex对应的mutations完成业务逻辑。

#### Vuex高级用法
若有多个组件需要使用store的数据且经过相同操作后的结果，我们可以使用getters进行复用。
```js
const store = new Vuex.store({
    state:{
        list:[1,2,3,4,5]
    },
    getters:{
        filteredList: state=>{
            return state.list.filter(item=>item>3);
        },
        listCount: (state, getters)=>{
            return getters.filteredList.length;
        }
    }
})
```
另外**getters**下的函数也能使用其他的getter结果。getters,mutations函数的参数第一位必须为state

mutation里不应该使用异步操作数据，需要用actions选项。action在组件内通过```$store.dispatch```触发。在action内提交mutation，看上例.
在组件中例如函数通过```$store.dispatch```触发```actions```的异步操作，然后函数内部访问```mutation```来改变store内部数据。
```javascript
//index.vue
<template>
    <button @click="handleasynIncrement">1s +1</button>
</template>
<script>
export default{
    method:{
        handleasynIncrement(){
            this.$store.dispatch('asynIncrement').then(()=>{
                console.log(this.$store.state.count);
            })
        }
    }
}
<script>
```

若涉及改变数据就是用mutations， 若涉及业务逻辑就使用actions。

**modules**
state分割到不同模块。 每个module内有state、getters、mutiations、actions, 且可以多层嵌套。
```js
const moduleA={
    state:{
        count:0
    },
    getters:{
        sumCount(state, getters, rootState){
            return state.count + rootState.count;
        }
    },
    actions:{...},
    mutations:{...}
}
const moduleB={
    state:{...},
    getters:{...},
    actions:{...},
    mutations:{...}
}

const store = new Vuex.store({
    modules:{
        a:moduleA,
        b:moduleB
    }
})

store.state.a
```



# NPM
包管理工具

安装公共包
>npm install <package_name>

安装会在当前目录新建```node_modules```目录并下载包到此目录。<br>
注意： 若当前目录没有package.json进行限制，则默认下载最新版本，否则安装满足package.json声明的版本。

安装作用域包
>npm install @scope/package-name

安装特定版本公共包
>npm install example-package@beta

全局下载与安装。可以将包作为本地的工具
>npm install -g <package_name>

若出现```EACCES permissions error```参考下面链接解决
https://docs.npmjs.com/downloading-and-installing-packages-globally

## 更新包
### 更新本地包
移动到package.json文件所在目录下
>cd /path/to/project

更新
>npm update

验证更新结果：应该无输出
>npm outdated

### 更新全局安装包
使用不大于2.6版本的npm，如下更新
>npm install npm@latest -g

2.6版本NPM更新
查看需要更新的包
>npm outdated -g --depth=0

更新单个或全部全局包
>npm update -g <package_name><br>
>npm update -g 

## 使用包
```js
var lodash = require('lodash'); //引入非作用域包

var projectName = require("@scope/package-name");//引入作用域包

var output = lodash.without([1, 2, 3], 1);
console.log(output);
```

package.json
手动更改版本
```
{
  "dependencies": {
    "@package_name": "^1.0.0",
    "@scope/package_name": "^1.0.0"
  }
}
```


## 报错处理
```Cannot find module" errors```<br>
未安装对应包

```deprecated packages```
- 更新包
- 更新依赖包

## 当不再需要某个包，卸载
>npm uninstall <package_name><br>
npm uinstall <@scope/package_name>

package.json中移除
>npm uninstall --save <package_name><br>
npm uninstall --save <@scope/package_name>

若使用了例如开发环境dev，移除指令为
>npm uninstall --save-dev package_name

**查看目录确保移除**
- Unix system (such as OSX): ls node_modules
- Windows systems: dir node_modules
  
移除全局包
>npm uninstall -g <package_name>
npm uninstall -g <@scope/package_name>

### 代理
代理的核心是在返回的头部添加一项```Access-Control-Allow-Origin```为```'*'```,来允许所有域访问。





# 微信小程序

```app.js```对小程序进行初始化
```app.json``` 项目配置文件
有以下属性：
```pages```
```window```
- navigationBarBackgroundColor：导航栏的颜色，默认为#000000（黑色）。
- navigationBarTextStyle：导航栏的文字颜色，只支持black（黑色）或white（白色），默认为white。
- navigationBarTitleText：导航栏的文字，默认为空。


### JSON格式要求
- 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。
- 原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。
- 字符串必须使用双引号表示，不能使用单引号。
- 对象的键名必须放在双引号里面。
- 数组或对象最后一个成员的后面，不能加逗号。

注意，null、空数组和空对象都是合法的 JSON 值。
```js
JSON.stringify('foo') === "foo" // false
JSON.stringify('foo') === "\"foo\"" // true

JSON.stringify(false) // "false"
JSON.stringify('false') // "\"false\""
```
对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify()过滤<br>
数组的成员是undefined、函数或 XML 对象，则这些值被转成null。<br>
正则对象会被转成空对象<br>
JSON.stringify()方法会忽略对象的不可遍历的属性。
```js
var obj = {};
Object.defineProperties(obj, {
  'foo': {
    value: 1,
    enumerable: true
  },
  'bar': {
    value: 2,
    enumerable: false
  }
});

JSON.stringify(obj); // "{"foo":1}"
```

JSON.stringify()方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串, 只对对象有效。 或者一个函数，能够递归地遍历每个对象进行处理。
```js
function f(key, value) {
    console.log(key,':',value);
  if (typeof value === "number") {
    value = 2 * value;
  }
    
  return value;
}

JSON.stringify({ a: 1, b: 2 }, f)
```
返回值
```
 : {a: 1, b: 2}
VM312:2 a : 1
VM312:2 b : 2
"{\"a\":2,\"b\":4}"
```

## 小程序事件
事件传播分两个阶段，先是捕获阶段（由上层元素向下层元素传播），然后是冒泡阶段（由下层元素向上层元素传播）。
<br>同一个事件在同一个元素上面其实会触发两次：捕获阶段一次，冒泡阶段一次.

按键绑定
```
<button bind:tap="handlefunc"></button>
```

通过事件去修改页面数据时使用```this.setData()```而不是直接```this.value = newvalue;```这会导致数据不一致

**动态提示 Toast**
```js
Page({
    handleClick(event){
        this.setData({
            name: '李四'
        }, function(){
            wx.showToast({
                title:'操作完成',
                duration:700   //持续700ms
            });

        });
    }
});
```

**对话框 Modal**
```js
...
    handleClick(event){
        const that= this;
        wx.showModal({
            title:'操作',
            content:'确认修改',
            success(res){
                if(res.confirm){
                    that.setData({
                        name: '王五'                       
                    }, function(){
                        wx.showToast({
                            title:'完成',
                            duration:700
                        });
                    });
                }else if(res.cancel){
                    console.log('取消修改');
                }
                
            }
        })
    }
...

```
setData()方法定义在页面实例上面, success不是定义在页面实例上的。

使用```JSON Server```提供数据支持
>npm install -g json-server

创建```db.json```存放JSON数据， 访问
```
{
  "posts": [
    { "id": 1, "title": "json-server", "author": "typicode" }
  ],
  "comments": [
    { "id": 1, "body": "some comment", "postId": 1 }
  ],
  "profile": { "name": "typicode" }
}
```

>json-server --watch db.json

```http://localhost:3000/posts/1```

```<open-data>```支持的用户信息如下。

- userNickName：用户昵称
- userAvatarUrl：用户头像
- userGender：用户性别
- userCity：用户所在城市
- userProvince：用户所在省份
- userCountry：用户所在国家
- userLanguage：用户的语言

## 规定
屏幕宽度为20rem，750rpx


### 文本的省略号
```css
.text{
    width:200px;
    
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}

```

多行文本溢出


```white-space: nowrap```的意思是除非遇到换行标签，否则不换行。

scroll-behavior: smooth; //根据定义慢慢移动
scroll-behavior: auto; //立即移动

点击绑定数据并传递index
```html
<view wx:for="{{books}}" data-id="{{index}}" bind:tap="change">{{item.name}}</view>
```
```js
data:{
    books:[
        {
            isclick:false
        },
        {
            isclick:false
        }
    ],
    value: 1
}
change(e){
    let index = e.currentTarget.dataset.id;
    let objattr = `books[${index}].isclick`;
    for(let i=0; i<this.data.books.length; i++){
        ...
    }
    this.setData({
        [objattr]: true
    }),
    this.setData({
        value: 2
    })
}
```
在函数内访问data数据都要通过```this.data```， 使用```this.setData({})```传入的是一个对象，若修改对象属性值，则在外部放到字符串或字符串模板内，再在对象内用```[]```包裹

**wx:for 嵌套下的item**
```html
<view wx:for="{{books}}">
    <view wx:for="{item.list}}" wx:for-item="value" wx:for-index="idx">{{value}}</view>
</view>
```

```wx：key ```是用来标识唯一的属性的，如果是静态数据可以```wx:key="{{index}}"```
若是动态例如可排序的数组，则不能这样绑定，可以```wx:key="*this*"```

```<scroll-view>```用来设置分类导航滚动条
```html
<scroll-view scroll-y scroll-with-animation style="{{height}}rpx">
```

小程序获取屏幕高度
```wx.getSystemInfo()```
wx.getSystemInfo中有3个高度，分别是：
- screenHeight：屏幕高度
- windowHeight：窗口高度
- statusBarHeight：状态栏高度

```flex-warp: nowarp;```会被摆放在一行

小程序组件使用多个slot，需要在component.js中开启属性```multipleSlots:true```,之后通过组件内元素```<slot name="a"> ```同```<view slot="a">```一一对应
```js
Component({
  options: {
    virtualHost: true,
    multipleSlots:true
  },
  properties:{
      propA: Number,
      propB: Number
  }
}
```
```html
<component-tag prop-a="{{dataA}}" prop-b="{{dataB}}"></component-tag>
```
```js
Component({
  options: {
    styleIsolation: 'isolated'
  }
})
```

用来隔离样式，也能在小程序json离修改
```json
{
  "styleIsolation": "isolated"
}
```
采取下面的方法依然可以获得页面或者父组件的样式
> <view class="~page-class"></view> 引用页面样式
> <view class="^page-class"></view> 引用父组件样式
获得外部传入的类样式，需要在component中申明。
```js
Component({
  externalClasses: ['my-class']
})

<com-tag class="my-class"></com-tag>
```

将组件设为虚拟的，可以领组件和页面的样式继续配合
```html
<view style="display:flex">
    <com-tag ></com-tag>
</view>

//component.wxml
<view style="flex:1">
    <view></view>
</view>

//component.js
component({
    options:{
        virtualHost:true
    }
})
```


### 组件数据监听器
监听的若是对象的属性，则对象改变或对象的属性改变```setData```都会触发监听器
数组对应值的监听包括了当前值以及整个数组的变化。
```js
component({
    observer:{
        'some.filed.**':function(filed){
            filed === this.data.some.filed
        },
        'arr[4]': function(arr4){
            arr4 === this.data.arr[4]
        }
    },
    attached: function(){
        this.setData({
        'some.field': { /* ... */ }
        })
        // 这样也会触发上面的 observer
        this.setData({
        'some.field.xxx': { /* ... */ }
        })
        // 这样还是会触发上面的 observer
        this.setData({
        'some': { /* ... */ }
        })
    },
    methods:{
        add(){
            this.setData({
                arr: this.data.arr.concat(11)
            })
        }
    }
})
```

### 列表点击获得索引
```<view wx:for="{{arr}}" data-index="{{index}}" bindtap="change"></view>```
```js
change(e){
    let index = e.currentTarget.dataset.index;
}
```
需要注意的是data-xxx 可以自定义，会把数据放入的```e.currentTarget.dataset.xxx```上

### Promise 实现JS异步编程

```js
<view wx:for="{{list}}" wx:for-index="id" wx:for-item="lan">
    {{id}} : {{lan}}
    </view>
```

## 小程序容器组件
### View视图组件
### scroll-view滚动视图组件
- 必须明确尺寸
- scroll-into-view定位属性的优先级高于scroll-top/scroll-left
- scroll-top/scroll-left设置值必须为数值，不能带单位
### swiper 轮播组件
swiper内只能放swiper-item， item内可以放其他标签
```js
<swiper>
    <swiper-item item-id="1"></swipter-item>
</swiper>
```

### movable-view可拖拽组件
movable-view必须放置在movable-area容器组件内。area必须明确尺寸，movable-view尺寸要小于它；若大于它则效果和scroll-view基本一致

### 浮层视图组件
用于自定义原生组件。最好采用真机测试
- cover-view浮层文本视图
- cover-image 浮层图片视图

## 基础视图组件
# icon组件

小程序导航栈最多支持10层
switchTab 可以跳转tabBar页面, 其他都不行

## target 和 currentTarget区别
target：触发事件的源组件(事件注册/绑定所在组件)

currentTarget：事件触发的当前事件（当前事件，可能是触发事件的源组件，可能是触发的事件组件（即触发事件源组件的子元素），此时点击子元还是父元素，都是当前事件，应用e.currentTarget）。

### 音频播放
基础库 1.6.0 开始支持，低版本需做兼容处理。
```js
var InnerAudioCtx =  wx.createInnerAudioContext()
InnerAudioCtx.src = "/audio/DVA.MP3";   //必须使用绝对地址
InnerAudioCtx.play();
InnerAudioCtx.onplay(()=>console.log('正在播放'));
InnerAudioCtx.onError(()=>console.log('播放出错'));
InnerAudioCtx.onCanplay(()=>console.log('可播放'));
```
当列表播放时，使用同一个实例，用destory的方式，当播放不同音频时。
使用`InnerAudioCtx.src`赋值音频时，若存在汉字，需要先转码
