# Java基础
## HashMap、ConcurrentHashMap、Hashtable
#### HashMap在多线程下存在线程问题，一般如何处理这种情况
* 使用Collections.synchronizedMap(Map)创建安全的map集合
> **Collections.synchronizedMap实现线程安全的原理：** SynchronizedMap内部维护了一个普通对象Map和排斥锁mutex，在调用Collections.synchronizedMap（）方法时，要传入调用SynchronizedMap的对象，之后再操作map时，就会对方法上锁
* Hashtable
> **与HashMap的区别：**
> （1）和HashMap相比，Hashtable是线程安全的，适用于多线程情况，但是效率较为低下——因为Hashtable对数据操作的时候，会全部上锁。
> （2）HashMap允许存在键值均为null的情况，Hashtable不允许。
> （3）初始容量不同：HashMap为16，Hashtable为11；
> （4）扩容机制不同：当现有容量大于总容量\*负载因子时，HashMap扩容规则
> （5）迭代器不同：HashMap的迭代器时fail-fast的，而Hashtable的迭代器不是
> 注：fail-fast：当用迭代器便利集合对象时，如果遍历过程中对集合对象进行了增删改，会抛出错误
* ConcurrentHashMap
> **ConcurrentHashMap为什么并发程度高：**底层是由Segment数组、HashEntry组成的，其中的HashEntry部分用volitile修饰，保证修改可见性，运行get方法的时候时不需要加锁的。由于ConcurrentHashMap使用了分段锁技术，其中Segment继承了ReentrantLock，并不会像HashTable那样不管是put还是get操作都需要做同步处理，当一个线程占用锁访问一个Segment时，不会影响到其他的Segment



## ArrayList、LinkedList
## 红黑树、B树
# 类加载机制
# 垃圾回收机制
# 多进程、多线程
## 进程
#### 进程简介
进程是程序一次运行的过程，是系统运行程序的基本单位
#### 进程间进行通信的方式
* 消息传递（匿名管道——用于具有亲缘关系的父子进程和兄弟进程之间的通信、有名管道——没有亲缘关系的两个进程间的通信，遵循先进先出原则、消息队列）
* 同步（互斥量——只有拥有互斥对象的线程才能访问公共资源、信号量——多个线程可以同时访问同一资源，不过需要控制同一时刻访问此资源的最大线程量）
* 共享内存（多个进程可以同时访问同一个内存空间，不同进程可以及时看到共享内存中资源的更新，需要同步机制）
* 远程调用

## 线程
#### 线程简介
线程是比进程更小的执行单位，一个进程在执行过程中可以产生多个线程，系统在产生一个线程、或是在多个线程见进行切换时，负担比进程小的多。多个进程之间一般是独立的，而线程不同，同一进程中的不同线程很有可能相互影响，线程开销小，但不利于资源的管理和保护，而进程相反。
#### 线程的生命周期和状态
线程在其生命周期的任一时刻，只可能处于下列6种状态的其中一种：

| 状态名称 | 说明 |
| --- | --- |
| New | 初始状态，线程被构建但还没有运行start（）方法 |
| Runnable | 运行状态 |
| Blocked | 阻塞状态 |
| Waiting | 等待状态 |
| Time_Waiting | 超时等待状态 ，不同于Waiting状态，Time_Waiting可以在指定事件后自行返回|
| Terminated | 终止状态 |
#### 线程的上下文切换
CPU在任一时刻只能被一个线程使用，为了让多线程程序可以有效运行，CPU为每个线程分配时间片，当一个线程的时间片用完后就会重新处于就绪状态。当前线程在执行完时间片切换另一个线程的之前，会先保存自己的状态，以便下次切换回这个线程时，可以再加载这个状态。
#### 线程死锁
##### 线程死锁的产生条件
1）互斥条件：该资源在任一时刻只能被一个线程占用
2）请求与保持条件：当一个线程因请求资源而阻塞的时候，不释放自己已经占用的资源
3）不剥夺条件：线程已获得的资源在未使用完成之前，不会被其他线程掠夺，只能自己使用完成之后释放
4）循环等待条件：若干线程首位相连形成一种循环等待资源的关系
##### 线程死锁的避免
1）破坏互斥条件：无法破坏
2）破坏请求与保持条件：一次性请求到全部资源
3）破坏不剥夺条件：占用部分资源的线程在访问其他资源时，若申请不到，可以主动释放自己已经占有的资源
4）破坏循环等待条件：设置资源申请顺序按序申请资源
#### Synchronized关键字
[synchronized详解](https://cloud.tencent.com/developer/article/1465413)
##### 简介
synchronized关键字解决多线程之间访问资源的同步性，即被synchronized关键字修饰的方法或代码块在同一时间，只能被一个线程执行。
早期synchronized关键字是属于重量级的，因其是依赖操作系统完成的，每次线程的切换都要操作系统的帮助才能完成，而操作系统实现线程的切换需要从用户态切换到内核态，时间成本相对较高。在JAVA6版本之后，官方从JVM对synchronized进行较大优化，引入自旋锁，自适应锁，偏向锁、轻量级锁等技术减少所操作的开销。
##### synchronized特性
1）原子性
2）可见性
3）有序性
4）可重入性
##### synchronized的使用方式
1）修饰实例方法：作用于当前对象实例，进入同步代码前要获得当前对象实例的锁
2）修饰静态方法：给类加锁，作用于类（因为静态资源不属于任何一个实例，不管new了多少，该资源只有一份）
3）修饰代码块：对给定对象或类加锁
> 双重校验锁实现单例模式
```Java
public class Singleton{
    private volatile static Singleton singleton;
    //volatile保证代码不被重排，多线程下保证数据可见性
    private Singleton(){
    }
    public static Singleton getInstance(){
        if(singleton==null){//第一重校验，若单例已被创建，则不进入同步代码块，不用竞争锁
            synchronized(Singleton.class){
                if(singleton == null){//第二重校验，为满足线程安全，如下场景：当singleton还未被初始化，此时线程1和线程2都调用getInstance()方法，都通过了第一层校验，若此时线程1先执行同步代码块中的方法，new一个实例。之后线程2再次执行同步代码块中的方法时，若没有第二重校验，则会再次new一个实例
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```




##### JVM对Synchronized的优化
1、锁膨胀
锁有四种状态，会根据实际情况膨胀，膨胀方向为：无锁->偏向锁->轻量级锁->重量级锁
1）偏向锁：减少了同一线程获取锁的代价。若大多数情况下，锁不存在竞争，都由同一个线程获取，则此时就是偏向锁。
当一个线程获取锁之后，锁就会自动进入偏向锁模式，改变Mark Word结构。当同一线程再次申请锁时，只要检查Mark Word中的锁标记为偏向锁、比较当前线程ID与Mark Word中的线程ID是否一致即可，省去了锁申请的开销。
2）轻量级锁：当有第二个线程申请锁时，就会自动升级为轻量级锁，注意，第二个线程只是申请锁，并不存在锁竞争，可以一前一后交替执行代码块。
3）重量级锁：同一时间有多个线程竞争锁时，就会升级为重量级锁，并且锁的开销也会增大。
2、锁消除
在JIT编译时，对运行上下扫描，消除不可能存在竞争的锁
3、锁粗化
扩大锁的范围，避免反复的申请和释放带来的消耗，如：
```Java
for(int i=0;i<100;i++){
    synchronized(this){
        System.out.println("hello world");
    }
}
//锁粗化为：
synchronized(this){
    for(int i=0;i<100;i++){
        System.out.println("hello world");
    }
}
```

##### synchronized和Reentrantlock的区别
1）都是可重入锁
2）synchronized依赖JVM实现，Reentrantlock依赖于API实现（需要lock（）和unlock（）配合try/catch实现）
3）Reentrantlock可以实现一些高级功能：
* 等待可中断：正在等待锁的线程可以终止等待，去做别的事
* 可实现公平锁和非公平锁：所谓公平锁，就是先申请的线程会先获得锁。synchronized时非公平锁
* 可实现选择性通知
#### 线程池的好处
1）降低资源消耗：可重复利用以创建的线程，可以减少线程创建和销毁的资源消耗
2）提高响应速度：任务到达时，不必等到线程创建完成就能执行
3）提高线程的可管理性：系统资源有限，不能无限的创建线程，线程池方便了线程的统一监控、调优、和分配
#### AQS
##### AQS简介
AQS是用来构建锁和同步器的框架，Reentrantlock、Semaphore等就是基于AQS的。AQS的核心思想是当被请求的资源时空闲时，直接获得该资源；当被请求资源被占用时，则该线程加入CLH（虚拟双向队列）中等待，FIFO
AQS对资源的共享方式有：1、Exclusive（独占） 2、share（共享）
AQS用一个int型的state变量标识同步状态，以Reentrantlock为例，state初始化为0，当线程A调用lock()时，该线程会独占其锁，并把state+1；当重入时，会再对state+1，A获取多少次锁就要释放多少次锁，直到state=0时，别的线程才可以继续获取

#### CAS
> CAS是乐观锁的一种实现方式，操作流程为：在读取数据时，不进行加锁，在准备写回数据时，比较原值是否被修改，若未被其他线程修改，则写回，若已被修改，则重新执行读取流程
> 是一种乐观策略，认为并发操作并不总会发生
> **是否CAS一定能保证数据没有被别的线程修改？** 不能，ABA问题就不能判断（ABA数据被一个线程由原来的A改为B，又被另一个问题改为A）
> **ABA问题怎么解决？** 通过添加版本号，每次修改值的时候，会再带一个版本号，每次判断的时候，判断版本号是否一致，判断成功就把版本号加1。

