## 简介
Redis（Remote Dictionary Server远程字典服务）是一个开源的、支持网络、可基于内存也可持久化的日志型、Key-Value数据库，是一个非关系型数据库。

## Redis与其他数据库相比的优势
1、性能极高，读写速度快
> **WHY？** 因为Redis使用了单线程架构和IO多路复用模型来实现高性能的内存数据库服务
> 1）Redis使用了纯内存访问，所有数据都存放在内存中
> 2）非阻塞IO，Redis使用epoll作为IO多路复用技术的实现，再加上Redis本身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络IO上占用过多的时间。
> 3）单线程避免了线程切换和竞争产生的消耗
> 注：Redis的单线程指的是网络请求模块使用了一个线程（不需要考虑并发安全性），即一个线程处理所有的网络请求，其他模块仍用了多线程。
> 
2、丰富的数据类型，Redis支持Strings,Lists,Hashes,Sets即Ordered Sets数据类型操作
3、事务，Redis通过MULTI、EXEC、WATCH命令来实现事务（WATCH用来监视一个或多个Key，当这个Key在）。Redis中所有的操作都是原子性的，单个操作是原子性的，多个操作也支持事务，但是不保证原子性，用MULTI和EXEC指令包起来
> Redis的事务本质上是一组指令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程中，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。
> Redis单个命令保证原子性，但Redis没有在事务上增加任何维持原子性的机制，事务可以理解为一个打包的批量执行脚本，但批量指令并非原子性操作，中间某条指令的失败并不会导致前面已做指令的回滚，也不会造成后续的指令不做。

## Redis功能丰富
（1）提供了键过期功能，可以实现缓存
（2）提供了发布订阅功能，可以实现消息队列
（3）支持Lua脚本，可以创建新的Redis命令
（4）提供了简单的事务功能，能在一定程度上保证事务特性
（5）提供了流水线功能，客户端能将一批命令一次性传到Redis，减少网络开销
（6）设置过期时间，即对Redis数据库中的值可以设置一个过期时间，到了指定时间，Redis如何对其进行删除呢？
> 定期删除：Redis默认每过100ms就**随机抽取**一些设置了过期时间的key，检查其是否还在生存周期中，如果过期就将其删除。随机抽取是因为Redis中数据量较大时，若隔100ms就全部便利一遍数据库，对CPU的很大的负载
> 惰性删除：定期删除的随机抽取导致很多过了生存周期的key依旧没有被删除。因此，惰性删除为假如过期key没有被定期删除删掉，还留在内存里，除非再去查这个过期key，才会被Redis删除掉，否则就一直存放在内存里
>
> 若定期删除没有删掉，又长期不搜索某个过期的key导致不能惰性删除，使得大量过期的key大量堆积，占用内存资源怎么解决呢？——内存淘汰机制
> * volatile-lru：从已经设置过期时间的数据集中，挑选出最近最少使用的数据淘汰
> * volatile-ttl：从已经设置过期时间的数据集中，挑选将要过期的数据淘汰
> * volatile-random：从已经设置过期时间的数据集中，任意选择数据淘汰
> * allkeys-lru：在内存不足以容纳新的写入数据时，从键空间中选取最近最少使用的淘汰（常用）
> * allkeys-random：在数据集中任意选择数据淘汰
> * no-eviction：在内存不足时，禁止新数据写入。（不常用）

（7）做缓存
> **用Redis做缓存和用Map/guava做缓存有什么区别呢？**
> 缓存氛围本地缓存和分布式缓存，Map/guava为本地内存，特点是轻量和快速，生命周期随JVM的销毁而结束，当有多实例的情况下，每个实例都要保存一份缓存，不具备数据一致性；Redis为分布内存，多个实例共同使用一个缓存，缺点是需要保证Redis缓存服务器的高可用，程序结构变得复杂
> 


## Redis持久化

Redis数据都存在内存里，如果突然宕机，数据就会全部丢失，因此必须有一种机制来保证Redis的数据不会因为故障而丢失，即持久化机制。
#### RDB快照
##### RDB简介
RDB其实就是把数据以快照的形式保存在磁盘上。RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是将某一时刻内存中的数据以快照的方式写入二进制文件中，故需要一种触发机制来实现这个过程，对于RDB来说，提供了两种机制：save、bgsave：
**1、save**
该命令会阻塞当前Redis服务器，在执行save命令期间，Redis不能执行其他命令，直到RDB过程完成。执行完成时，如果存在老的RDB文件，就用新的代替旧的。
**2、bgsave**
执行该命令时，Redis会在后台异步进行快照工作，快照同时还可以相应客户端请求，具体操作如下：
Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束，阻塞只发生在fork阶段，时间很短
##### RDB优势和劣势
1）优势
* RBD文件紧凑、全量备份，适用于灾难恢复
* 在生成RDB文件的时候，Redis会fork（）出一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作
* RDB在恢复大数据集时的速度比AOF快
2）劣势
* 全量备份耗时相对较长，会占用额外的内存空间
* 在子进程进行RDB操作时，所有在快照持久化期间修改的数据都不会被保存，可能丢失数据
#### AOF简介
全量备份总是耗时的，AOF机制在redis每收到一个写命令时都通过write函数追加到磁盘中的AOF文件中——日志记录，AOF流程如下：
1）命令的实时写入，将命令写入AOF缓冲区中
2）AOF缓冲区根据相应的策略向硬盘做同步操作
3）随着AOF文件越来越大，Redis要定期对AOF文件进行重写
>AOF重写可以产生一个新的AOF文件（新的AOF文件和原有AOF文件中保存的数据库状态一致，但体积更小），是通过读取数据库中的键值对实现的，而不是读取旧AOF文件，类似快照。
在AOF重写时，Redis执行bgrewriteaof命令，会将内存中的数据保存到临时文件中，fork（）出一个新的子进程来完成AOF重写操作。此时Redis服务器会维护一个AOF重写缓冲区，该缓冲区会记录在子进程进行AOF重写期间，Redis主进程执行的其他命令，当子进程完成AOF重写时，服务器会讲缓冲区中的所有内容追加到新AOF文件的末尾，最后用新的AOF文件代替旧的AOF文件。

4）Redis服务重启，加载AOF文件进行数据恢复
